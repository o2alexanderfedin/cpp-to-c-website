<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <title>WASM Transpiler Direct Test</title>
  <style>
    body { font-family: monospace; padding: 20px; background: #1a1a1a; color: #00ff00; }
    button { background: #339af0; color: white; border: none; padding: 10px 20px; margin: 10px 5px; cursor: pointer; }
    .success { color: #51cf66; }
    .error { color: #ff6b6b; }
    .info { color: #74c0fc; }
    .code { background: #2d2d2d; padding: 15px; margin: 10px 0; overflow-x: auto; border-left: 3px solid #51cf66; }
    #log { margin-top: 20px; white-space: pre-wrap; }
  </style>
</head>
<body>
  <h1>üß™ WASM Transpiler - Direct Test</h1>
  <p>This test initializes WASM and runs transpilation directly without file upload.</p>

  <button onclick="runTest()">‚ñ∂Ô∏è Run Full E2E Test</button>

  <div id="results"></div>
  <div id="log"></div>

  <script type="module">
    const logEl = document.getElementById('log');
    const resultsEl = document.getElementById('results');

    function log(msg, type = 'info') {
      const timestamp = new Date().toLocaleTimeString();
      const div = document.createElement('div');
      div.className = type;
      div.textContent = `[${timestamp}] ${msg}`;
      logEl.appendChild(div);
    }

    window.runTest = async function() {
      resultsEl.innerHTML = '';
      logEl.innerHTML = '';

      try {
        // Step 1: Load WASM module
        log('Step 1: Loading WASM module...', 'info');
        const { default: createCppToC } = await import('/cpp-to-c-website/wasm/cpptoc.js');
        log('‚úì Module factory loaded', 'success');

        // Step 2: Initialize module
        log('Step 2: Initializing WASM runtime...', 'info');
        let moduleInstance = null;
        let runtimeReady = false;

        await createCppToC({
          noInitialRun: true,
          print: (text) => log(`[stdout] ${text}`, 'info'),
          printErr: (text) => log(`[stderr] ${text}`, 'info'),
          locateFile: (path) => path.endsWith('.wasm') ? `/cpp-to-c-website/wasm/${path}` : path,
          onRuntimeInitialized: function() {
            moduleInstance = this;
            runtimeReady = true;
          }
        });

        // Wait for initialization
        let waited = 0;
        while (!runtimeReady && waited < 10000) {
          await new Promise(r => setTimeout(r, 50));
          waited += 50;
        }

        if (!moduleInstance?.FS) {
          throw new Error('Module FS not available');
        }

        log('‚úì WASM runtime initialized', 'success');
        log(`  FS available: ${typeof moduleInstance.FS}`, 'info');
        log(`  callMain available: ${typeof moduleInstance.callMain}`, 'info');

        // Step 3: Create test C++ file
        log('Step 3: Creating test C++ file in virtual FS...', 'info');
        const testCpp = `// Calculator class
class Calculator {
private:
    int value;
public:
    Calculator() : value(0) {}
    void add(int x) { value += x; }
    int getValue() const { return value; }
};

int main() {
    Calculator calc;
    calc.add(5);
    calc.add(10);
    return calc.getValue();
}`;

        const FS = moduleInstance.FS;
        try { FS.mkdir('/project'); } catch(e) {}
        try { FS.mkdir('/output'); } catch(e) {}

        FS.writeFile('/project/Calculator.cpp', testCpp);
        log('‚úì Written Calculator.cpp (244 bytes)', 'success');

        // Step 4: Run transpiler
        log('Step 4: Running transpiler...', 'info');
        log('Command: cpptoc --source-dir /project --output-dir /output', 'info');

        const exitCode = moduleInstance.callMain([
          '--source-dir', '/project',
          '--output-dir', '/output'
        ]);

        log(`‚úì Transpiler completed (exit code: ${exitCode})`, exitCode === 0 ? 'success' : 'error');

        // Step 5: Read output files
        log('Step 5: Reading generated output...', 'info');
        const outputFiles = FS.readdir('/output').filter(f => f !== '.' && f !== '..');

        if (outputFiles.length === 0) {
          log('‚ö† No output files generated', 'error');
          return;
        }

        log(`‚úì Generated ${outputFiles.length} files: ${outputFiles.join(', ')}`, 'success');

        // Display results
        let html = '<h2>üìÑ Generated C Code</h2>';

        for (const filename of outputFiles) {
          const content = FS.readFile(`/output/${filename}`, { encoding: 'utf8' });
          log(`  ${filename}: ${content.length} bytes`, 'success');

          html += `<h3>${filename}</h3><div class="code">${escapeHtml(content)}</div>`;
        }

        resultsEl.innerHTML = html;

        log('=== ‚úÖ TRANSPILATION TEST COMPLETE ===', 'success');
        log('All steps passed! WASM transpiler is fully functional.', 'success');

      } catch (error) {
        log(`‚úó Test failed: ${error.message}`, 'error');
        log(`Stack: ${error.stack}`, 'error');
      }
    };

    function escapeHtml(text) {
      const div = document.createElement('div');
      div.textContent = text;
      return div.innerHTML;
    }

    log('Page loaded. Click "Run Full E2E Test" to begin.', 'info');
  </script>
</body>
</html>
