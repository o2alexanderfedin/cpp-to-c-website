# Phase 2, Plan 02-04: Tree View Tests

**Phase**: 02 - File Tree View & Source Selection
**Plan**: 02-04 - Tree View Tests
**Scope**: Unit and E2E tests for tree component
**Estimate**: 1-2 hours

---

## Objective

Create comprehensive test coverage for the FileTreeView component and source selection flow. This includes unit tests for component behavior, E2E tests for user interactions, and performance tests for large file sets.

**Why**: Tests ensure the tree view handles edge cases correctly, performs well with large directories, and provides a reliable user experience. They also prevent regressions as we continue to enhance the wizard.

**Coverage Target**: >80% test coverage for FileTreeView component and related utilities

---

## Context

**Existing code from 02-01, 02-02, and 02-03:**
- `@src/components/playground/wizard/FileTreeView.tsx` - virtualized tree component with react-window
- `@src/components/playground/wizard/Step1SourceSelection.tsx` - source directory selection with tree integration
- `@src/lib/playground/fileTreeUtils.ts` - utilities for tree data transformation
- `@src/types/fileTree.ts` - TypeScript types for tree nodes

**Existing test patterns:**
- Unit tests: Vitest + React Testing Library (`@testing-library/react`)
- E2E tests: Playwright with Page Object Model
- Test location: `src/**/*.test.{ts,tsx}` for unit tests, `tests/e2e/specs/*.spec.ts` for E2E
- Test utilities: `userEvent` for user interactions, `waitFor` for async operations

**Testing infrastructure:**
- Vitest for unit testing (with happy-dom for DOM simulation)
- Playwright for E2E testing (Chromium, Firefox, WebKit)
- Coverage tracking with `@vitest/coverage-v8`
- Scripts: `npm run test` (unit), `npm run test:e2e` (E2E), `npm run test:coverage` (coverage report)

**Testing approach:**
- Unit tests: Component rendering, expand/collapse logic, virtualization behavior, filtering
- Integration tests: File discovery, tree population, filtering integration
- E2E tests: Source selection flow, tree interactions, keyboard navigation
- Performance tests: Large directory handling (2000+ files), render time benchmarks

**Reference implementations:**
- `@src/components/playground/wizard/WizardStepper.test.tsx` - component test structure
- `@src/components/playground/DirectorySelector.test.tsx` - directory handling tests
- `@tests/e2e/specs/wizard-navigation.spec.ts` - E2E test patterns
- `@tests/e2e/pages/WizardPage.ts` - page object model pattern

---

## Tasks

### Task 1: FileTreeView Unit Tests
**Type**: test
**Files**: `src/components/playground/wizard/FileTreeView.test.tsx`

**Action**:
Create comprehensive unit tests for FileTreeView component:

```typescript
import { describe, it, expect, vi, beforeEach } from 'vitest';
import { render, screen, fireEvent, waitFor } from '@testing-library/react';
import userEvent from '@testing-library/user-event';
import { FileTreeView } from './FileTreeView';
import type { FileTreeNode } from '@/types/fileTree';

describe('FileTreeView', () => {
  const mockTreeData: FileTreeNode[] = [
    {
      id: '1',
      name: 'src',
      type: 'directory',
      path: '/project/src',
      children: [
        {
          id: '1-1',
          name: 'main.cpp',
          type: 'file',
          path: '/project/src/main.cpp',
          size: 1024,
        },
        {
          id: '1-2',
          name: 'utils',
          type: 'directory',
          path: '/project/src/utils',
          children: [
            {
              id: '1-2-1',
              name: 'helper.h',
              type: 'file',
              path: '/project/src/utils/helper.h',
              size: 512,
            },
          ],
        },
      ],
    },
    {
      id: '2',
      name: 'README.md',
      type: 'file',
      path: '/project/README.md',
      size: 256,
    },
  ];

  describe('rendering', () => {
    it('renders empty state when no data provided', () => {
      render(<FileTreeView data={[]} />);
      expect(screen.getByText(/no files/i)).toBeInTheDocument();
    });

    it('renders tree with files and folders', () => {
      render(<FileTreeView data={mockTreeData} />);

      expect(screen.getByText('src')).toBeInTheDocument();
      expect(screen.getByText('README.md')).toBeInTheDocument();
    });

    it('displays folder icons for directories', () => {
      render(<FileTreeView data={mockTreeData} />);

      const folderIcons = screen.getAllByTestId('folder-icon');
      expect(folderIcons.length).toBeGreaterThan(0);
    });

    it('displays file icons for files', () => {
      render(<FileTreeView data={mockTreeData} />);

      const fileIcons = screen.getAllByTestId('file-icon');
      expect(fileIcons.length).toBeGreaterThan(0);
    });

    it('shows correct indentation for nested items', () => {
      render(<FileTreeView data={mockTreeData} />);

      // Expand src folder first
      const srcFolder = screen.getByText('src');
      fireEvent.click(srcFolder);

      // Check that main.cpp has indentation
      const mainFile = screen.getByText('main.cpp');
      const parentElement = mainFile.closest('[data-level]');
      expect(parentElement).toHaveAttribute('data-level', '1');
    });
  });

  describe('expand/collapse behavior', () => {
    it('starts with folders collapsed by default', () => {
      render(<FileTreeView data={mockTreeData} />);

      // Child files should not be visible initially
      expect(screen.queryByText('main.cpp')).not.toBeInTheDocument();
      expect(screen.queryByText('utils')).not.toBeInTheDocument();
    });

    it('expands folder when clicked', async () => {
      render(<FileTreeView data={mockTreeData} />);

      const srcFolder = screen.getByText('src');
      await userEvent.click(srcFolder);

      // Child files should now be visible
      await waitFor(() => {
        expect(screen.getByText('main.cpp')).toBeInTheDocument();
        expect(screen.getByText('utils')).toBeInTheDocument();
      });
    });

    it('collapses expanded folder when clicked again', async () => {
      render(<FileTreeView data={mockTreeData} />);

      const srcFolder = screen.getByText('src');

      // Expand
      await userEvent.click(srcFolder);
      await waitFor(() => expect(screen.getByText('main.cpp')).toBeInTheDocument());

      // Collapse
      await userEvent.click(srcFolder);
      await waitFor(() => expect(screen.queryByText('main.cpp')).not.toBeInTheDocument());
    });

    it('expands nested folders independently', async () => {
      render(<FileTreeView data={mockTreeData} />);

      // Expand src
      const srcFolder = screen.getByText('src');
      await userEvent.click(srcFolder);
      await waitFor(() => expect(screen.getByText('utils')).toBeInTheDocument());

      // Expand utils
      const utilsFolder = screen.getByText('utils');
      await userEvent.click(utilsFolder);
      await waitFor(() => expect(screen.getByText('helper.h')).toBeInTheDocument());
    });

    it('shows expand/collapse icon on folders', () => {
      render(<FileTreeView data={mockTreeData} />);

      const expandIcons = screen.getAllByTestId('expand-icon');
      expect(expandIcons.length).toBeGreaterThan(0);
    });

    it('does not show expand/collapse icon on files', () => {
      render(<FileTreeView data={mockTreeData} />);

      const readmeFile = screen.getByText('README.md');
      const parentElement = readmeFile.closest('[data-expandable]');
      expect(parentElement).toHaveAttribute('data-expandable', 'false');
    });
  });

  describe('virtualization', () => {
    it('uses VariableSizeList for rendering', () => {
      const { container } = render(<FileTreeView data={mockTreeData} />);

      // react-window adds specific class names
      const virtualList = container.querySelector('[style*="overflow"]');
      expect(virtualList).toBeInTheDocument();
    });

    it('renders only visible items initially', () => {
      // Create large dataset
      const largeData: FileTreeNode[] = Array.from({ length: 100 }, (_, i) => ({
        id: `file-${i}`,
        name: `file-${i}.cpp`,
        type: 'file',
        path: `/project/file-${i}.cpp`,
        size: 1024,
      }));

      const { container } = render(
        <FileTreeView data={largeData} height={400} itemHeight={32} />
      );

      // Should only render items that fit in viewport (~12 items for 400px height)
      const visibleItems = container.querySelectorAll('[data-tree-item]');
      expect(visibleItems.length).toBeLessThan(20); // Some buffer for overscan
    });

    it('updates visible items on scroll', async () => {
      const largeData: FileTreeNode[] = Array.from({ length: 100 }, (_, i) => ({
        id: `file-${i}`,
        name: `file-${i}.cpp`,
        type: 'file',
        path: `/project/file-${i}.cpp`,
        size: 1024,
      }));

      const { container } = render(
        <FileTreeView data={largeData} height={400} itemHeight={32} />
      );

      const scrollContainer = container.querySelector('[style*="overflow"]');
      expect(scrollContainer).toBeInTheDocument();

      // Simulate scroll
      if (scrollContainer) {
        fireEvent.scroll(scrollContainer, { target: { scrollTop: 1000 } });

        // Wait for scroll to be processed
        await waitFor(() => {
          // Different items should now be visible
          const items = container.querySelectorAll('[data-tree-item]');
          expect(items.length).toBeGreaterThan(0);
        });
      }
    });
  });

  describe('file selection', () => {
    it('calls onFileClick when file is clicked', async () => {
      const onFileClick = vi.fn();
      render(<FileTreeView data={mockTreeData} onFileClick={onFileClick} />);

      const readmeFile = screen.getByText('README.md');
      await userEvent.click(readmeFile);

      expect(onFileClick).toHaveBeenCalledWith(mockTreeData[1]);
    });

    it('highlights selected file', async () => {
      render(<FileTreeView data={mockTreeData} />);

      const readmeFile = screen.getByText('README.md');
      await userEvent.click(readmeFile);

      const parentElement = readmeFile.closest('[data-selected]');
      expect(parentElement).toHaveAttribute('data-selected', 'true');
    });

    it('updates selection when different file clicked', async () => {
      render(<FileTreeView data={mockTreeData} />);

      // Expand src folder
      const srcFolder = screen.getByText('src');
      await userEvent.click(srcFolder);
      await waitFor(() => expect(screen.getByText('main.cpp')).toBeInTheDocument());

      // Select main.cpp
      const mainFile = screen.getByText('main.cpp');
      await userEvent.click(mainFile);

      let selectedElement = mainFile.closest('[data-selected="true"]');
      expect(selectedElement).toBeInTheDocument();

      // Select README.md
      const readmeFile = screen.getByText('README.md');
      await userEvent.click(readmeFile);

      // main.cpp should no longer be selected
      selectedElement = mainFile.closest('[data-selected="true"]');
      expect(selectedElement).not.toBeInTheDocument();

      // README.md should be selected
      selectedElement = readmeFile.closest('[data-selected="true"]');
      expect(selectedElement).toBeInTheDocument();
    });
  });

  describe('filtering', () => {
    it('filters tree by file name', () => {
      render(<FileTreeView data={mockTreeData} filter="main" />);

      // Expand folders to show filtered results
      const srcFolder = screen.getByText('src');
      fireEvent.click(srcFolder);

      expect(screen.getByText('main.cpp')).toBeInTheDocument();
      expect(screen.queryByText('README.md')).not.toBeInTheDocument();
    });

    it('filters by file extension', () => {
      render(<FileTreeView data={mockTreeData} filter=".h" />);

      // Should show only .h files and their parent folders
      const srcFolder = screen.getByText('src');
      fireEvent.click(srcFolder);

      const utilsFolder = screen.getByText('utils');
      fireEvent.click(utilsFolder);

      expect(screen.getByText('helper.h')).toBeInTheDocument();
      expect(screen.queryByText('main.cpp')).not.toBeInTheDocument();
    });

    it('shows all files when filter is empty', () => {
      const { rerender } = render(<FileTreeView data={mockTreeData} filter="test" />);

      // Initially filtered
      expect(screen.queryByText('README.md')).not.toBeInTheDocument();

      // Clear filter
      rerender(<FileTreeView data={mockTreeData} filter="" />);

      // All files should be visible (after expanding)
      expect(screen.getByText('README.md')).toBeInTheDocument();
    });

    it('shows no results message when filter matches nothing', () => {
      render(<FileTreeView data={mockTreeData} filter="nonexistent" />);

      expect(screen.getByText(/no files match/i)).toBeInTheDocument();
    });
  });

  describe('keyboard navigation', () => {
    it('supports arrow key navigation', async () => {
      render(<FileTreeView data={mockTreeData} />);

      const treeContainer = screen.getByRole('tree');
      treeContainer.focus();

      // Press down arrow
      await userEvent.keyboard('{ArrowDown}');

      // First item should be focused
      const srcFolder = screen.getByText('src');
      expect(srcFolder).toHaveFocus();
    });

    it('expands folder with Enter key', async () => {
      render(<FileTreeView data={mockTreeData} />);

      const srcFolder = screen.getByText('src');
      srcFolder.focus();

      await userEvent.keyboard('{Enter}');

      await waitFor(() => {
        expect(screen.getByText('main.cpp')).toBeInTheDocument();
      });
    });

    it('collapses folder with Enter key when expanded', async () => {
      render(<FileTreeView data={mockTreeData} />);

      const srcFolder = screen.getByText('src');

      // Expand
      srcFolder.focus();
      await userEvent.keyboard('{Enter}');
      await waitFor(() => expect(screen.getByText('main.cpp')).toBeInTheDocument());

      // Collapse
      await userEvent.keyboard('{Enter}');
      await waitFor(() => expect(screen.queryByText('main.cpp')).not.toBeInTheDocument());
    });

    it('expands folder with ArrowRight key', async () => {
      render(<FileTreeView data={mockTreeData} />);

      const srcFolder = screen.getByText('src');
      srcFolder.focus();

      await userEvent.keyboard('{ArrowRight}');

      await waitFor(() => {
        expect(screen.getByText('main.cpp')).toBeInTheDocument();
      });
    });

    it('collapses folder with ArrowLeft key', async () => {
      render(<FileTreeView data={mockTreeData} />);

      const srcFolder = screen.getByText('src');

      // Expand
      srcFolder.focus();
      await userEvent.keyboard('{ArrowRight}');
      await waitFor(() => expect(screen.getByText('main.cpp')).toBeInTheDocument());

      // Collapse
      await userEvent.keyboard('{ArrowLeft}');
      await waitFor(() => expect(screen.queryByText('main.cpp')).not.toBeInTheDocument());
    });
  });

  describe('accessibility', () => {
    it('has proper ARIA role for tree', () => {
      render(<FileTreeView data={mockTreeData} />);

      expect(screen.getByRole('tree')).toBeInTheDocument();
    });

    it('has proper ARIA role for tree items', () => {
      render(<FileTreeView data={mockTreeData} />);

      const treeItems = screen.getAllByRole('treeitem');
      expect(treeItems.length).toBeGreaterThan(0);
    });

    it('sets aria-expanded on folders', () => {
      render(<FileTreeView data={mockTreeData} />);

      const srcFolder = screen.getByText('src').closest('[role="treeitem"]');
      expect(srcFolder).toHaveAttribute('aria-expanded', 'false');
    });

    it('updates aria-expanded when folder is expanded', async () => {
      render(<FileTreeView data={mockTreeData} />);

      const srcFolder = screen.getByText('src');
      await userEvent.click(srcFolder);

      const treeItem = srcFolder.closest('[role="treeitem"]');
      await waitFor(() => {
        expect(treeItem).toHaveAttribute('aria-expanded', 'true');
      });
    });

    it('sets aria-selected on selected file', async () => {
      render(<FileTreeView data={mockTreeData} />);

      const readmeFile = screen.getByText('README.md');
      await userEvent.click(readmeFile);

      const treeItem = readmeFile.closest('[role="treeitem"]');
      expect(treeItem).toHaveAttribute('aria-selected', 'true');
    });

    it('has proper aria-label', () => {
      render(<FileTreeView data={mockTreeData} ariaLabel="Source files" />);

      const tree = screen.getByRole('tree');
      expect(tree).toHaveAttribute('aria-label', 'Source files');
    });
  });

  describe('performance', () => {
    it('handles large file list efficiently', () => {
      const largeData: FileTreeNode[] = Array.from({ length: 2000 }, (_, i) => ({
        id: `file-${i}`,
        name: `file-${i}.cpp`,
        type: 'file',
        path: `/project/file-${i}.cpp`,
        size: 1024,
      }));

      const startTime = performance.now();
      render(<FileTreeView data={largeData} height={600} itemHeight={32} />);
      const endTime = performance.now();

      // Should render in less than 200ms
      expect(endTime - startTime).toBeLessThan(200);
    });

    it('handles deeply nested structure efficiently', () => {
      // Create 10 levels of nesting
      const createNestedStructure = (depth: number, parentPath = ''): FileTreeNode => {
        const path = `${parentPath}/level-${depth}`;
        return {
          id: `dir-${depth}`,
          name: `level-${depth}`,
          type: 'directory',
          path,
          children: depth > 0 ? [createNestedStructure(depth - 1, path)] : [
            {
              id: 'file-deep',
              name: 'deep-file.cpp',
              type: 'file',
              path: `${path}/deep-file.cpp`,
              size: 1024,
            }
          ],
        };
      };

      const deepData = [createNestedStructure(10)];

      const startTime = performance.now();
      render(<FileTreeView data={deepData} />);
      const endTime = performance.now();

      expect(endTime - startTime).toBeLessThan(100);
    });
  });

  describe('edge cases', () => {
    it('handles empty folder gracefully', () => {
      const emptyFolderData: FileTreeNode[] = [
        {
          id: '1',
          name: 'empty-folder',
          type: 'directory',
          path: '/project/empty-folder',
          children: [],
        },
      ];

      render(<FileTreeView data={emptyFolderData} />);

      const folder = screen.getByText('empty-folder');
      fireEvent.click(folder);

      expect(screen.getByText(/no files in this folder/i)).toBeInTheDocument();
    });

    it('handles special characters in file names', () => {
      const specialCharsData: FileTreeNode[] = [
        {
          id: '1',
          name: 'file (with) [brackets] & special.cpp',
          type: 'file',
          path: '/project/file (with) [brackets] & special.cpp',
          size: 1024,
        },
      ];

      render(<FileTreeView data={specialCharsData} />);

      expect(screen.getByText('file (with) [brackets] & special.cpp')).toBeInTheDocument();
    });

    it('handles very long file names', () => {
      const longNameData: FileTreeNode[] = [
        {
          id: '1',
          name: 'a'.repeat(200) + '.cpp',
          type: 'file',
          path: '/project/' + 'a'.repeat(200) + '.cpp',
          size: 1024,
        },
      ];

      const { container } = render(<FileTreeView data={longNameData} />);

      // Long name should be truncated with ellipsis
      const fileName = container.querySelector('[data-tree-item]');
      expect(fileName).toHaveStyle({ textOverflow: 'ellipsis' });
    });

    it('handles missing or invalid data gracefully', () => {
      // @ts-expect-error Testing invalid data
      render(<FileTreeView data={null} />);

      expect(screen.getByText(/no files/i)).toBeInTheDocument();
    });
  });
});
```

**Verify**:
- All tests pass with `npm run test FileTreeView.test.tsx`
- Coverage >80% for FileTreeView component
- Tests cover rendering, expansion, virtualization, selection, filtering, keyboard nav, accessibility
- Performance tests validate <200ms render time for 2000+ files

**Done when**: Unit tests pass, coverage target met

---

### Task 2: File Tree Utils Unit Tests
**Type**: test
**Files**: `src/lib/playground/fileTreeUtils.test.ts`

**Action**:
Create unit tests for file tree utility functions:

```typescript
import { describe, it, expect } from 'vitest';
import {
  flattenTree,
  filterTree,
  findNodeById,
  getExpandedPaths,
  calculateTreeHeight,
  sortTreeNodes,
} from './fileTreeUtils';
import type { FileTreeNode } from '@/types/fileTree';

describe('fileTreeUtils', () => {
  const mockTree: FileTreeNode[] = [
    {
      id: '1',
      name: 'src',
      type: 'directory',
      path: '/project/src',
      children: [
        {
          id: '1-1',
          name: 'main.cpp',
          type: 'file',
          path: '/project/src/main.cpp',
          size: 1024,
        },
        {
          id: '1-2',
          name: 'utils',
          type: 'directory',
          path: '/project/src/utils',
          children: [
            {
              id: '1-2-1',
              name: 'helper.h',
              type: 'file',
              path: '/project/src/utils/helper.h',
              size: 512,
            },
          ],
        },
      ],
    },
    {
      id: '2',
      name: 'README.md',
      type: 'file',
      path: '/project/README.md',
      size: 256,
    },
  ];

  describe('flattenTree', () => {
    it('flattens nested tree into array', () => {
      const flattened = flattenTree(mockTree, new Set());

      expect(flattened).toHaveLength(2); // Only top-level items when nothing expanded
      expect(flattened[0].id).toBe('1');
      expect(flattened[1].id).toBe('2');
    });

    it('includes children when folder is expanded', () => {
      const expanded = new Set(['1']);
      const flattened = flattenTree(mockTree, expanded);

      expect(flattened).toHaveLength(4); // src, main.cpp, utils, README.md
      expect(flattened.map(n => n.id)).toContain('1-1');
      expect(flattened.map(n => n.id)).toContain('1-2');
    });

    it('includes deeply nested children when all parents expanded', () => {
      const expanded = new Set(['1', '1-2']);
      const flattened = flattenTree(mockTree, expanded);

      expect(flattened).toHaveLength(5); // All nodes
      expect(flattened.map(n => n.id)).toContain('1-2-1');
    });

    it('preserves tree order', () => {
      const expanded = new Set(['1']);
      const flattened = flattenTree(mockTree, expanded);

      const ids = flattened.map(n => n.id);
      expect(ids.indexOf('1')).toBeLessThan(ids.indexOf('1-1'));
      expect(ids.indexOf('1-1')).toBeLessThan(ids.indexOf('1-2'));
    });
  });

  describe('filterTree', () => {
    it('returns all nodes when filter is empty', () => {
      const filtered = filterTree(mockTree, '');
      expect(filtered).toEqual(mockTree);
    });

    it('filters by file name', () => {
      const filtered = filterTree(mockTree, 'main');

      expect(filtered).toHaveLength(1);
      expect(filtered[0].id).toBe('1'); // src folder
      expect(filtered[0].children).toHaveLength(1);
      expect(filtered[0].children![0].name).toBe('main.cpp');
    });

    it('filters by file extension', () => {
      const filtered = filterTree(mockTree, '.h');

      expect(filtered).toHaveLength(1);
      expect(filtered[0].children).toHaveLength(1); // utils folder
      expect(filtered[0].children![0].children).toHaveLength(1);
      expect(filtered[0].children![0].children![0].name).toBe('helper.h');
    });

    it('is case insensitive', () => {
      const filtered = filterTree(mockTree, 'MAIN');

      expect(filtered).toHaveLength(1);
      expect(filtered[0].children![0].name).toBe('main.cpp');
    });

    it('returns empty array when no matches', () => {
      const filtered = filterTree(mockTree, 'nonexistent');
      expect(filtered).toEqual([]);
    });

    it('includes parent folders of matching files', () => {
      const filtered = filterTree(mockTree, 'helper');

      // Should include src and utils folders even though they don't match
      expect(filtered).toHaveLength(1);
      expect(filtered[0].name).toBe('src');
      expect(filtered[0].children).toHaveLength(1);
      expect(filtered[0].children![0].name).toBe('utils');
    });
  });

  describe('findNodeById', () => {
    it('finds top-level node', () => {
      const node = findNodeById(mockTree, '2');
      expect(node?.name).toBe('README.md');
    });

    it('finds nested node', () => {
      const node = findNodeById(mockTree, '1-1');
      expect(node?.name).toBe('main.cpp');
    });

    it('finds deeply nested node', () => {
      const node = findNodeById(mockTree, '1-2-1');
      expect(node?.name).toBe('helper.h');
    });

    it('returns undefined for non-existent id', () => {
      const node = findNodeById(mockTree, 'nonexistent');
      expect(node).toBeUndefined();
    });
  });

  describe('getExpandedPaths', () => {
    it('returns empty set for empty tree', () => {
      const expanded = getExpandedPaths([]);
      expect(expanded.size).toBe(0);
    });

    it('returns all folder ids that should be expanded', () => {
      const expanded = getExpandedPaths(mockTree, true);

      expect(expanded.has('1')).toBe(true);
      expect(expanded.has('1-2')).toBe(true);
      expect(expanded.has('2')).toBe(false); // Not a folder
    });

    it('returns empty set when expandAll is false', () => {
      const expanded = getExpandedPaths(mockTree, false);
      expect(expanded.size).toBe(0);
    });
  });

  describe('calculateTreeHeight', () => {
    it('calculates height for collapsed tree', () => {
      const height = calculateTreeHeight(mockTree, new Set(), 32);
      expect(height).toBe(64); // 2 items * 32px
    });

    it('calculates height for expanded tree', () => {
      const expanded = new Set(['1']);
      const height = calculateTreeHeight(mockTree, expanded, 32);
      expect(height).toBe(128); // 4 items * 32px
    });

    it('calculates height for fully expanded tree', () => {
      const expanded = new Set(['1', '1-2']);
      const height = calculateTreeHeight(mockTree, expanded, 32);
      expect(height).toBe(160); // 5 items * 32px
    });
  });

  describe('sortTreeNodes', () => {
    const unsortedTree: FileTreeNode[] = [
      {
        id: '2',
        name: 'zebra.cpp',
        type: 'file',
        path: '/project/zebra.cpp',
        size: 100,
      },
      {
        id: '1',
        name: 'alpha',
        type: 'directory',
        path: '/project/alpha',
        children: [],
      },
      {
        id: '3',
        name: 'beta.cpp',
        type: 'file',
        path: '/project/beta.cpp',
        size: 100,
      },
    ];

    it('sorts folders before files', () => {
      const sorted = sortTreeNodes(unsortedTree);

      expect(sorted[0].type).toBe('directory');
      expect(sorted[1].type).toBe('file');
      expect(sorted[2].type).toBe('file');
    });

    it('sorts alphabetically within type', () => {
      const sorted = sortTreeNodes(unsortedTree);

      expect(sorted[0].name).toBe('alpha');
      expect(sorted[1].name).toBe('beta.cpp');
      expect(sorted[2].name).toBe('zebra.cpp');
    });

    it('sorts recursively', () => {
      const treeWithChildren: FileTreeNode[] = [
        {
          id: '1',
          name: 'folder',
          type: 'directory',
          path: '/project/folder',
          children: [
            {
              id: '1-2',
              name: 'z.cpp',
              type: 'file',
              path: '/project/folder/z.cpp',
              size: 100,
            },
            {
              id: '1-1',
              name: 'a.cpp',
              type: 'file',
              path: '/project/folder/a.cpp',
              size: 100,
            },
          ],
        },
      ];

      const sorted = sortTreeNodes(treeWithChildren);

      expect(sorted[0].children![0].name).toBe('a.cpp');
      expect(sorted[0].children![1].name).toBe('z.cpp');
    });
  });
});
```

**Verify**:
- All utility function tests pass
- Edge cases covered (empty trees, deeply nested structures)
- Performance validated for large datasets

**Done when**: Utility tests pass with >90% coverage

---

### Task 3: Source Selection Integration Tests
**Type**: test
**Files**: `src/components/playground/wizard/Step1SourceSelection.test.tsx`

**Action**:
Create integration tests for Step 1 with file tree:

```typescript
import { describe, it, expect, vi } from 'vitest';
import { render, screen, waitFor } from '@testing-library/react';
import userEvent from '@testing-library/user-event';
import { Step1SourceSelection } from './Step1SourceSelection';
import type { WizardState } from './types';

describe('Step1SourceSelection', () => {
  const mockState: WizardState = {
    sourceDir: null,
    sourceFiles: [],
    targetDir: null,
    transpilationStatus: 'idle',
    currentFile: null,
  };

  const mockFileSystem = {
    kind: 'directory',
    name: 'test-project',
    values: async function* () {
      yield { kind: 'file', name: 'main.cpp' };
      yield { kind: 'file', name: 'helper.h' };
      yield { kind: 'directory', name: 'src', values: async function* () {
        yield { kind: 'file', name: 'utils.cpp' };
      }};
    },
  };

  describe('directory selection', () => {
    it('shows directory selector initially', () => {
      render(
        <Step1SourceSelection
          state={mockState}
          onSourceDirSelected={vi.fn()}
        />
      );

      expect(screen.getByRole('button', { name: /select directory/i })).toBeInTheDocument();
    });

    it('calls onSourceDirSelected when directory is chosen', async () => {
      const onSourceDirSelected = vi.fn();

      // Mock File System Access API
      (window as any).showDirectoryPicker = vi.fn().mockResolvedValue(mockFileSystem);

      render(
        <Step1SourceSelection
          state={mockState}
          onSourceDirSelected={onSourceDirSelected}
        />
      );

      const selectButton = screen.getByRole('button', { name: /select directory/i });
      await userEvent.click(selectButton);

      await waitFor(() => {
        expect(onSourceDirSelected).toHaveBeenCalled();
      });
    });

    it('displays error when directory selection fails', async () => {
      (window as any).showDirectoryPicker = vi.fn().mockRejectedValue(
        new Error('Permission denied')
      );

      render(
        <Step1SourceSelection
          state={mockState}
          onSourceDirSelected={vi.fn()}
        />
      );

      const selectButton = screen.getByRole('button', { name: /select directory/i });
      await userEvent.click(selectButton);

      await waitFor(() => {
        expect(screen.getByRole('alert')).toHaveTextContent(/error/i);
      });
    });
  });

  describe('file tree display', () => {
    const stateWithFiles: WizardState = {
      ...mockState,
      sourceDir: mockFileSystem as any,
      sourceFiles: [
        {
          id: '1',
          name: 'main.cpp',
          type: 'file',
          path: '/project/main.cpp',
          size: 1024,
        },
        {
          id: '2',
          name: 'helper.h',
          type: 'file',
          path: '/project/helper.h',
          size: 512,
        },
      ],
    };

    it('shows file tree after directory is selected', () => {
      render(
        <Step1SourceSelection
          state={stateWithFiles}
          onSourceDirSelected={vi.fn()}
        />
      );

      expect(screen.getByRole('tree')).toBeInTheDocument();
      expect(screen.getByText('main.cpp')).toBeInTheDocument();
      expect(screen.getByText('helper.h')).toBeInTheDocument();
    });

    it('displays file count', () => {
      render(
        <Step1SourceSelection
          state={stateWithFiles}
          onSourceDirSelected={vi.fn()}
        />
      );

      expect(screen.getByText(/2 files/i)).toBeInTheDocument();
    });

    it('displays total size', () => {
      render(
        <Step1SourceSelection
          state={stateWithFiles}
          onSourceDirSelected={vi.fn()}
        />
      );

      // 1024 + 512 = 1536 bytes = 1.5 KB
      expect(screen.getByText(/1\.5\s*KB/i)).toBeInTheDocument();
    });

    it('allows changing directory', async () => {
      const onSourceDirSelected = vi.fn();

      render(
        <Step1SourceSelection
          state={stateWithFiles}
          onSourceDirSelected={onSourceDirSelected}
        />
      );

      const changeButton = screen.getByRole('button', { name: /change directory/i });
      expect(changeButton).toBeInTheDocument();

      (window as any).showDirectoryPicker = vi.fn().mockResolvedValue(mockFileSystem);

      await userEvent.click(changeButton);

      await waitFor(() => {
        expect(onSourceDirSelected).toHaveBeenCalled();
      });
    });
  });

  describe('file filtering', () => {
    const stateWithManyFiles: WizardState = {
      ...mockState,
      sourceDir: mockFileSystem as any,
      sourceFiles: [
        {
          id: '1',
          name: 'main.cpp',
          type: 'file',
          path: '/project/main.cpp',
          size: 1024,
        },
        {
          id: '2',
          name: 'helper.h',
          type: 'file',
          path: '/project/helper.h',
          size: 512,
        },
        {
          id: '3',
          name: 'README.md',
          type: 'file',
          path: '/project/README.md',
          size: 256,
        },
      ],
    };

    it('shows only C++ files by default', () => {
      render(
        <Step1SourceSelection
          state={stateWithManyFiles}
          onSourceDirSelected={vi.fn()}
        />
      );

      expect(screen.getByText('main.cpp')).toBeInTheDocument();
      expect(screen.getByText('helper.h')).toBeInTheDocument();
      expect(screen.queryByText('README.md')).not.toBeInTheDocument();
    });

    it('allows filtering with search input', async () => {
      render(
        <Step1SourceSelection
          state={stateWithManyFiles}
          onSourceDirSelected={vi.fn()}
        />
      );

      const searchInput = screen.getByRole('searchbox', { name: /search files/i });
      await userEvent.type(searchInput, 'main');

      expect(screen.getByText('main.cpp')).toBeInTheDocument();
      expect(screen.queryByText('helper.h')).not.toBeInTheDocument();
    });

    it('updates file count when filter is applied', async () => {
      render(
        <Step1SourceSelection
          state={stateWithManyFiles}
          onSourceDirSelected={vi.fn()}
        />
      );

      const searchInput = screen.getByRole('searchbox', { name: /search files/i });
      await userEvent.type(searchInput, 'main');

      expect(screen.getByText(/1 file/i)).toBeInTheDocument();
    });

    it('clears filter when search is cleared', async () => {
      render(
        <Step1SourceSelection
          state={stateWithManyFiles}
          onSourceDirSelected={vi.fn()}
        />
      );

      const searchInput = screen.getByRole('searchbox', { name: /search files/i });

      // Apply filter
      await userEvent.type(searchInput, 'main');
      expect(screen.queryByText('helper.h')).not.toBeInTheDocument();

      // Clear filter
      await userEvent.clear(searchInput);
      expect(screen.getByText('helper.h')).toBeInTheDocument();
    });
  });

  describe('accessibility', () => {
    it('has proper heading structure', () => {
      render(
        <Step1SourceSelection
          state={mockState}
          onSourceDirSelected={vi.fn()}
        />
      );

      expect(screen.getByRole('heading', { name: /step 1.*source/i })).toBeInTheDocument();
    });

    it('has accessible labels on interactive elements', () => {
      render(
        <Step1SourceSelection
          state={mockState}
          onSourceDirSelected={vi.fn()}
        />
      );

      const selectButton = screen.getByRole('button', { name: /select directory/i });
      expect(selectButton).toHaveAccessibleName();
    });

    it('announces file count to screen readers', () => {
      const stateWithFiles: WizardState = {
        ...mockState,
        sourceFiles: [
          { id: '1', name: 'main.cpp', type: 'file', path: '/project/main.cpp', size: 1024 },
        ],
      };

      render(
        <Step1SourceSelection
          state={stateWithFiles}
          onSourceDirSelected={vi.fn()}
        />
      );

      const fileCount = screen.getByText(/1 file/i);
      expect(fileCount).toHaveAttribute('aria-live', 'polite');
    });
  });
});
```

**Verify**:
- Integration tests pass
- Directory selection flow tested
- File tree integration tested
- Filtering integration tested

**Done when**: Step1 integration tests pass with >80% coverage

---

### Task 4: E2E Source Selection Tests
**Type**: test
**Files**: `tests/e2e/specs/wizard-source-selection.spec.ts`, `tests/e2e/pages/WizardPage.ts` (update)

**Action**:
Create E2E tests for source selection flow:

**Update WizardPage.ts:**
```typescript
// Add to existing WizardPage class
export class WizardPage extends BasePage {
  // ... existing properties ...

  readonly selectSourceButton: Locator;
  readonly fileTree: Locator;
  readonly fileTreeItems: Locator;
  readonly searchFilesInput: Locator;
  readonly fileCountDisplay: Locator;
  readonly changeDirectoryButton: Locator;

  constructor(page: Page) {
    super(page);
    // ... existing constructor code ...

    // Source selection elements
    this.selectSourceButton = page.getByRole('button', { name: /select directory/i });
    this.fileTree = page.getByRole('tree');
    this.fileTreeItems = page.getByRole('treeitem');
    this.searchFilesInput = page.getByRole('searchbox', { name: /search files/i });
    this.fileCountDisplay = page.locator('[data-testid="file-count"]');
    this.changeDirectoryButton = page.getByRole('button', { name: /change directory/i });
  }

  /**
   * Select a source directory using File System Access API
   * Note: This requires browser permissions and may need special handling in tests
   */
  async selectSourceDirectory(directoryName: string) {
    // This is a mock for E2E testing
    // In real tests, you may need to use browser context to grant permissions
    await this.selectSourceButton.click();
    // Wait for file tree to appear
    await this.fileTree.waitFor({ state: 'visible', timeout: 5000 });
  }

  /**
   * Expand a folder in the file tree
   */
  async expandFolder(folderName: string) {
    const folder = this.page.getByRole('treeitem', { name: new RegExp(folderName, 'i') });
    await folder.click();
    // Wait for children to appear
    await this.page.waitForTimeout(100);
  }

  /**
   * Select a file in the tree
   */
  async selectFile(fileName: string) {
    const file = this.page.getByRole('treeitem', { name: new RegExp(fileName, 'i') });
    await file.click();
  }

  /**
   * Search for files
   */
  async searchFiles(query: string) {
    await this.searchFilesInput.fill(query);
    // Wait for filter to apply
    await this.page.waitForTimeout(200);
  }

  /**
   * Get number of visible files in tree
   */
  async getVisibleFileCount(): Promise<number> {
    const items = await this.fileTreeItems.count();
    return items;
  }

  /**
   * Get file count from display
   */
  async getFileCountText(): Promise<string> {
    return await this.fileCountDisplay.textContent() || '';
  }
}
```

**Create wizard-source-selection.spec.ts:**
```typescript
import { test, expect } from '@playwright/test';
import { WizardPage } from '../pages/WizardPage';

test.describe('Wizard Source Selection', () => {
  let wizardPage: WizardPage;

  test.beforeEach(async ({ page }) => {
    wizardPage = new WizardPage(page);
    await wizardPage.goto();
  });

  test.describe('directory selection', () => {
    test('shows directory selector on Step 1', async () => {
      await expect(wizardPage.selectSourceButton).toBeVisible();
      await expect(wizardPage.selectSourceButton).toHaveAccessibleName(/select directory/i);
    });

    test('directory selector has drag-drop zone', async () => {
      const dropZone = wizardPage.page.getByTestId('drop-zone');
      await expect(dropZone).toBeVisible();
      await expect(dropZone).toContainText(/drag.*drop/i);
    });

    // Note: Actual directory selection requires browser permissions
    // In real tests, you would need to mock the File System Access API
    // or use a test directory with pre-granted permissions
    test.skip('selects directory and displays file tree', async ({ context }) => {
      // This test would require File System Access API permissions
      // and a test directory to select
      // Implementation depends on your test environment setup
    });
  });

  test.describe('file tree display', () => {
    test.beforeEach(async ({ page }) => {
      // Assume we have a mock that populates the tree with test data
      // In real tests, this would come from actual directory selection
      await page.evaluate(() => {
        // Mock file tree population
        window.dispatchEvent(new CustomEvent('test:populate-tree', {
          detail: {
            files: [
              { id: '1', name: 'main.cpp', type: 'file', path: '/test/main.cpp', size: 1024 },
              { id: '2', name: 'helper.h', type: 'file', path: '/test/helper.h', size: 512 },
              {
                id: '3',
                name: 'src',
                type: 'directory',
                path: '/test/src',
                children: [
                  { id: '3-1', name: 'utils.cpp', type: 'file', path: '/test/src/utils.cpp', size: 768 },
                ],
              },
            ],
          },
        }));
      });

      // Wait for tree to render
      await wizardPage.fileTree.waitFor({ state: 'visible' });
    });

    test('displays file tree after directory selection', async () => {
      await expect(wizardPage.fileTree).toBeVisible();
      await expect(wizardPage.fileTree).toHaveAttribute('role', 'tree');
    });

    test('shows files in tree', async () => {
      await expect(wizardPage.page.getByText('main.cpp')).toBeVisible();
      await expect(wizardPage.page.getByText('helper.h')).toBeVisible();
    });

    test('shows folders in tree', async () => {
      await expect(wizardPage.page.getByText('src')).toBeVisible();
    });

    test('displays file count', async () => {
      const count = await wizardPage.getFileCountText();
      expect(count).toMatch(/3 files/i);
    });

    test('displays total size', async () => {
      const sizeDisplay = wizardPage.page.locator('[data-testid="total-size"]');
      const size = await sizeDisplay.textContent();
      // 1024 + 512 + 768 = 2304 bytes = 2.25 KB
      expect(size).toMatch(/2\.2\s*KB/i);
    });

    test('allows changing directory', async () => {
      await expect(wizardPage.changeDirectoryButton).toBeVisible();
      await expect(wizardPage.changeDirectoryButton).toBeEnabled();
    });
  });

  test.describe('folder expansion', () => {
    test.beforeEach(async ({ page }) => {
      // Mock tree with folders
      await page.evaluate(() => {
        window.dispatchEvent(new CustomEvent('test:populate-tree', {
          detail: {
            files: [
              {
                id: '1',
                name: 'src',
                type: 'directory',
                path: '/test/src',
                children: [
                  { id: '1-1', name: 'main.cpp', type: 'file', path: '/test/src/main.cpp', size: 1024 },
                  {
                    id: '1-2',
                    name: 'utils',
                    type: 'directory',
                    path: '/test/src/utils',
                    children: [
                      { id: '1-2-1', name: 'helper.h', type: 'file', path: '/test/src/utils/helper.h', size: 512 },
                    ],
                  },
                ],
              },
            ],
          },
        }));
      });

      await wizardPage.fileTree.waitFor({ state: 'visible' });
    });

    test('folders are collapsed by default', async () => {
      // Children should not be visible
      await expect(wizardPage.page.getByText('main.cpp')).not.toBeVisible();
    });

    test('expands folder when clicked', async () => {
      await wizardPage.expandFolder('src');

      // Children should now be visible
      await expect(wizardPage.page.getByText('main.cpp')).toBeVisible();
      await expect(wizardPage.page.getByText('utils')).toBeVisible();
    });

    test('collapses folder when clicked again', async () => {
      // Expand
      await wizardPage.expandFolder('src');
      await expect(wizardPage.page.getByText('main.cpp')).toBeVisible();

      // Collapse
      await wizardPage.expandFolder('src');
      await expect(wizardPage.page.getByText('main.cpp')).not.toBeVisible();
    });

    test('expands nested folders', async () => {
      // Expand src
      await wizardPage.expandFolder('src');
      await expect(wizardPage.page.getByText('utils')).toBeVisible();

      // Expand utils
      await wizardPage.expandFolder('utils');
      await expect(wizardPage.page.getByText('helper.h')).toBeVisible();
    });

    test('updates aria-expanded attribute', async () => {
      const srcFolder = wizardPage.page.getByRole('treeitem', { name: /src/i });

      // Initially collapsed
      await expect(srcFolder).toHaveAttribute('aria-expanded', 'false');

      // Expand
      await wizardPage.expandFolder('src');
      await expect(srcFolder).toHaveAttribute('aria-expanded', 'true');
    });
  });

  test.describe('file filtering', () => {
    test.beforeEach(async ({ page }) => {
      // Mock tree with various file types
      await page.evaluate(() => {
        window.dispatchEvent(new CustomEvent('test:populate-tree', {
          detail: {
            files: [
              { id: '1', name: 'main.cpp', type: 'file', path: '/test/main.cpp', size: 1024 },
              { id: '2', name: 'helper.h', type: 'file', path: '/test/helper.h', size: 512 },
              { id: '3', name: 'utils.cpp', type: 'file', path: '/test/utils.cpp', size: 768 },
              { id: '4', name: 'README.md', type: 'file', path: '/test/README.md', size: 256 },
            ],
          },
        }));
      });

      await wizardPage.fileTree.waitFor({ state: 'visible' });
    });

    test('shows only C++ files by default', async () => {
      await expect(wizardPage.page.getByText('main.cpp')).toBeVisible();
      await expect(wizardPage.page.getByText('helper.h')).toBeVisible();
      await expect(wizardPage.page.getByText('utils.cpp')).toBeVisible();
      await expect(wizardPage.page.getByText('README.md')).not.toBeVisible();
    });

    test('has search input', async () => {
      await expect(wizardPage.searchFilesInput).toBeVisible();
      await expect(wizardPage.searchFilesInput).toHaveAttribute('placeholder', /search/i);
    });

    test('filters files by name', async () => {
      await wizardPage.searchFiles('main');

      await expect(wizardPage.page.getByText('main.cpp')).toBeVisible();
      await expect(wizardPage.page.getByText('helper.h')).not.toBeVisible();
      await expect(wizardPage.page.getByText('utils.cpp')).not.toBeVisible();
    });

    test('filters files by extension', async () => {
      await wizardPage.searchFiles('.h');

      await expect(wizardPage.page.getByText('helper.h')).toBeVisible();
      await expect(wizardPage.page.getByText('main.cpp')).not.toBeVisible();
    });

    test('filter is case insensitive', async () => {
      await wizardPage.searchFiles('MAIN');

      await expect(wizardPage.page.getByText('main.cpp')).toBeVisible();
    });

    test('updates file count when filtering', async () => {
      await wizardPage.searchFiles('main');

      const count = await wizardPage.getFileCountText();
      expect(count).toMatch(/1 file/i);
    });

    test('clears filter when search is cleared', async () => {
      await wizardPage.searchFiles('main');
      await expect(wizardPage.page.getByText('helper.h')).not.toBeVisible();

      await wizardPage.searchFilesInput.clear();

      await expect(wizardPage.page.getByText('helper.h')).toBeVisible();
    });

    test('shows no results message when filter matches nothing', async () => {
      await wizardPage.searchFiles('nonexistent');

      await expect(wizardPage.page.getByText(/no files match/i)).toBeVisible();
    });
  });

  test.describe('keyboard navigation', () => {
    test.beforeEach(async ({ page }) => {
      // Mock tree
      await page.evaluate(() => {
        window.dispatchEvent(new CustomEvent('test:populate-tree', {
          detail: {
            files: [
              { id: '1', name: 'main.cpp', type: 'file', path: '/test/main.cpp', size: 1024 },
              { id: '2', name: 'helper.h', type: 'file', path: '/test/helper.h', size: 512 },
            ],
          },
        }));
      });

      await wizardPage.fileTree.waitFor({ state: 'visible' });
    });

    test('tree is keyboard navigable', async ({ page }) => {
      await wizardPage.fileTree.focus();

      // Press down arrow
      await page.keyboard.press('ArrowDown');

      // First item should be focused
      const firstItem = wizardPage.page.getByRole('treeitem').first();
      await expect(firstItem).toBeFocused();
    });

    test('can navigate between items with arrow keys', async ({ page }) => {
      await wizardPage.fileTree.focus();

      await page.keyboard.press('ArrowDown');
      const firstItem = await wizardPage.page.getByRole('treeitem').first().textContent();

      await page.keyboard.press('ArrowDown');
      const secondItem = await wizardPage.page.getByRole('treeitem').nth(1).textContent();

      expect(firstItem).not.toBe(secondItem);
    });

    test('can expand folder with Enter key', async ({ page }) => {
      // Mock with folder
      await page.evaluate(() => {
        window.dispatchEvent(new CustomEvent('test:populate-tree', {
          detail: {
            files: [
              {
                id: '1',
                name: 'src',
                type: 'directory',
                path: '/test/src',
                children: [
                  { id: '1-1', name: 'main.cpp', type: 'file', path: '/test/src/main.cpp', size: 1024 },
                ],
              },
            ],
          },
        }));
      });

      await wizardPage.fileTree.waitFor({ state: 'visible' });
      await wizardPage.fileTree.focus();

      await page.keyboard.press('ArrowDown'); // Focus src folder
      await page.keyboard.press('Enter'); // Expand

      await expect(page.getByText('main.cpp')).toBeVisible();
    });
  });

  test.describe('accessibility', () => {
    test.beforeEach(async ({ page }) => {
      // Mock tree
      await page.evaluate(() => {
        window.dispatchEvent(new CustomEvent('test:populate-tree', {
          detail: {
            files: [
              { id: '1', name: 'main.cpp', type: 'file', path: '/test/main.cpp', size: 1024 },
            ],
          },
        }));
      });

      await wizardPage.fileTree.waitFor({ state: 'visible' });
    });

    test('tree has proper ARIA role', async () => {
      await expect(wizardPage.fileTree).toHaveAttribute('role', 'tree');
    });

    test('tree items have proper ARIA role', async () => {
      const items = wizardPage.fileTreeItems;
      const count = await items.count();
      expect(count).toBeGreaterThan(0);

      for (let i = 0; i < count; i++) {
        await expect(items.nth(i)).toHaveAttribute('role', 'treeitem');
      }
    });

    test('tree has accessible label', async () => {
      await expect(wizardPage.fileTree).toHaveAttribute('aria-label');
    });

    test('file count is announced to screen readers', async () => {
      await expect(wizardPage.fileCountDisplay).toHaveAttribute('aria-live', 'polite');
    });

    test('search input has accessible label', async () => {
      await expect(wizardPage.searchFilesInput).toHaveAccessibleName(/search/i);
    });
  });
});
```

**Verify**:
- E2E tests pass in Chromium
- Source selection flow tested
- Tree interactions tested
- Keyboard navigation verified
- Accessibility checked

**Done when**: E2E tests pass, all scenarios covered

---

### Task 5: Performance Tests
**Type**: test
**Files**: `src/components/playground/wizard/FileTreeView.perf.test.tsx`

**Action**:
Create performance benchmarks for large file sets:

```typescript
import { describe, it, expect } from 'vitest';
import { render } from '@testing-library/react';
import { FileTreeView } from './FileTreeView';
import type { FileTreeNode } from '@/types/fileTree';

describe('FileTreeView Performance', () => {
  const generateLargeFileSet = (count: number): FileTreeNode[] => {
    return Array.from({ length: count }, (_, i) => ({
      id: `file-${i}`,
      name: `file-${i}.cpp`,
      type: 'file' as const,
      path: `/project/file-${i}.cpp`,
      size: Math.floor(Math.random() * 10000),
    }));
  };

  const generateLargeFolderStructure = (
    depth: number,
    filesPerFolder: number,
    parentPath = ''
  ): FileTreeNode[] => {
    if (depth === 0) {
      return generateLargeFileSet(filesPerFolder).map((file, i) => ({
        ...file,
        path: `${parentPath}/${file.name}`,
      }));
    }

    return Array.from({ length: 5 }, (_, i) => {
      const folderPath = `${parentPath}/folder-${i}`;
      return {
        id: `folder-${depth}-${i}`,
        name: `folder-${i}`,
        type: 'directory' as const,
        path: folderPath,
        children: [
          ...generateLargeFolderStructure(depth - 1, filesPerFolder, folderPath),
        ],
      };
    });
  };

  describe('rendering performance', () => {
    it('renders 500 files in <100ms', () => {
      const data = generateLargeFileSet(500);

      const startTime = performance.now();
      render(<FileTreeView data={data} height={600} itemHeight={32} />);
      const endTime = performance.now();

      const renderTime = endTime - startTime;
      console.log(`500 files rendered in ${renderTime.toFixed(2)}ms`);
      expect(renderTime).toBeLessThan(100);
    });

    it('renders 1000 files in <150ms', () => {
      const data = generateLargeFileSet(1000);

      const startTime = performance.now();
      render(<FileTreeView data={data} height={600} itemHeight={32} />);
      const endTime = performance.now();

      const renderTime = endTime - startTime;
      console.log(`1000 files rendered in ${renderTime.toFixed(2)}ms`);
      expect(renderTime).toBeLessThan(150);
    });

    it('renders 2000 files in <200ms', () => {
      const data = generateLargeFileSet(2000);

      const startTime = performance.now();
      render(<FileTreeView data={data} height={600} itemHeight={32} />);
      const endTime = performance.now();

      const renderTime = endTime - startTime;
      console.log(`2000 files rendered in ${renderTime.toFixed(2)}ms`);
      expect(renderTime).toBeLessThan(200);
    });

    it('renders 5000 files in <500ms', () => {
      const data = generateLargeFileSet(5000);

      const startTime = performance.now();
      render(<FileTreeView data={data} height={600} itemHeight={32} />);
      const endTime = performance.now();

      const renderTime = endTime - startTime;
      console.log(`5000 files rendered in ${renderTime.toFixed(2)}ms`);
      expect(renderTime).toBeLessThan(500);
    });
  });

  describe('nested structure performance', () => {
    it('handles 5 levels of nesting efficiently', () => {
      const data = generateLargeFolderStructure(5, 10);

      const startTime = performance.now();
      render(<FileTreeView data={data} height={600} itemHeight={32} />);
      const endTime = performance.now();

      const renderTime = endTime - startTime;
      console.log(`5-level nested structure rendered in ${renderTime.toFixed(2)}ms`);
      expect(renderTime).toBeLessThan(200);
    });

    it('handles 10 levels of nesting efficiently', () => {
      const data = generateLargeFolderStructure(10, 5);

      const startTime = performance.now();
      render(<FileTreeView data={data} height={600} itemHeight={32} />);
      const endTime = performance.now();

      const renderTime = endTime - startTime;
      console.log(`10-level nested structure rendered in ${renderTime.toFixed(2)}ms`);
      expect(renderTime).toBeLessThan(300);
    });
  });

  describe('filtering performance', () => {
    it('filters 2000 files in <50ms', () => {
      const data = generateLargeFileSet(2000);

      const startTime = performance.now();
      render(<FileTreeView data={data} filter="file-1" height={600} itemHeight={32} />);
      const endTime = performance.now();

      const filterTime = endTime - startTime;
      console.log(`Filtered 2000 files in ${filterTime.toFixed(2)}ms`);
      expect(filterTime).toBeLessThan(50);
    });
  });

  describe('expansion performance', () => {
    it('expands large folder quickly', async () => {
      const data = [
        {
          id: 'root',
          name: 'root',
          type: 'directory' as const,
          path: '/root',
          children: generateLargeFileSet(1000),
        },
      ];

      const { getByText } = render(<FileTreeView data={data} height={600} itemHeight={32} />);

      const rootFolder = getByText('root');

      const startTime = performance.now();
      rootFolder.click();
      const endTime = performance.now();

      const expansionTime = endTime - startTime;
      console.log(`Expanded 1000-file folder in ${expansionTime.toFixed(2)}ms`);
      expect(expansionTime).toBeLessThan(50);
    });
  });

  describe('memory efficiency', () => {
    it('does not render all items in large list', () => {
      const data = generateLargeFileSet(2000);

      const { container } = render(
        <FileTreeView data={data} height={600} itemHeight={32} />
      );

      // With virtualization, only visible items + overscan should be rendered
      // For 600px height and 32px items, ~19 visible items + overscan (~5 items) = ~24 items
      const renderedItems = container.querySelectorAll('[data-tree-item]');

      console.log(`Rendered ${renderedItems.length} of 2000 items`);
      expect(renderedItems.length).toBeLessThan(50); // Much less than total
      expect(renderedItems.length).toBeGreaterThan(10); // But enough to fill viewport
    });
  });
});
```

**Verify**:
- Performance benchmarks pass
- 2000+ files render in <200ms
- Virtualization working correctly
- Memory usage optimized

**Done when**: Performance tests pass, benchmarks documented

---

### Task 6: Update Test Coverage Report
**Type**: update
**Files**: `tests/e2e/README.md`, `.planning/phases/02-file-tree-view/02-04-SUMMARY.md`

**Action**:
Update test documentation and create summary:

**Update tests/e2e/README.md:**
```markdown
## Wizard Tests

### Phase 1: Navigation ( Complete)
-  Forward navigation through all 4 steps
-  Backward navigation to previous steps
-  Button states (enabled/disabled at correct steps)
-  Step indicator highlighting
-  Keyboard navigation (Enter on focused buttons)
-  Accessibility (ARIA labels, roles, disabled states)

### Phase 2: Source Selection ( Complete)
-  Directory selection with File System Access API
-  File tree rendering and display
-  Folder expansion/collapse
-  File filtering by name and extension
-  Keyboard navigation in tree
-  Accessibility (tree roles, ARIA attributes)
-  Performance with 2000+ files
```

**Create 02-04-SUMMARY.md:**
```markdown
# Phase 2, Plan 02-04: Tree View Tests - COMPLETE

**Status**:  Complete
**Completed**: [date]
**Duration**: [actual time]

## What Was Built

- Comprehensive FileTreeView component unit tests
- File tree utilities unit tests
- Step1SourceSelection integration tests
- E2E tests for source selection flow
- Performance benchmarks for large file sets

## Files Created

- `src/components/playground/wizard/FileTreeView.test.tsx` - 200+ lines, 45+ tests
- `src/lib/playground/fileTreeUtils.test.ts` - 150+ lines, 25+ tests
- `src/components/playground/wizard/Step1SourceSelection.test.tsx` - 150+ lines, 20+ tests
- `tests/e2e/specs/wizard-source-selection.spec.ts` - 300+ lines, 30+ tests
- `src/components/playground/wizard/FileTreeView.perf.test.tsx` - 100+ lines, 10+ tests
- `tests/e2e/pages/WizardPage.ts` - UPDATED (added source selection methods)
- `tests/e2e/README.md` - UPDATED (Phase 2 coverage)

## Test Coverage

### Unit Tests
- FileTreeView: 90+ tests, >85% coverage
  - Rendering (empty state, files, folders, icons, indentation)
  - Expand/collapse behavior
  - Virtualization
  - File selection
  - Filtering
  - Keyboard navigation
  - Accessibility
  - Performance
  - Edge cases
- File tree utilities: 25+ tests, >90% coverage
- Step1 integration: 20+ tests, >80% coverage

### E2E Tests
- 30+ tests covering:
  - Directory selection
  - File tree display
  - Folder expansion
  - File filtering
  - Keyboard navigation
  - Accessibility

### Performance Benchmarks
- 500 files: <100ms render time
- 1000 files: <150ms render time
- 2000 files: <200ms render time 
- 5000 files: <500ms render time
- Nested structures: <300ms for 10 levels
- Filtering: <50ms for 2000 files

## Verification

 All unit tests pass (140+ tests)
 All E2E tests pass (30+ tests)
 Test coverage >80% for all components
 Performance benchmarks met
 Virtualization verified
 Keyboard navigation tested
 Accessibility verified
 Documentation updated

## Test Execution

```bash
# Unit tests
npm run test FileTreeView.test.tsx
npm run test fileTreeUtils.test.ts
npm run test Step1SourceSelection.test.tsx
npm run test FileTreeView.perf.test.tsx

# E2E tests
npm run test:e2e wizard-source-selection.spec.ts

# Coverage
npm run test:coverage
```

## Deviations from Plan

[None] OR [List any changes made during implementation]

## Next Steps

**Phase 2, Plan 02-04 Complete!** All tree view tests passing.

Ready for **Phase 3: Target Selection & Live Transpilation**

Phase 3 will add tests for:
- Target directory selection
- Conflict detection
- Live transpilation with tree highlighting
- Pause/resume functionality
- Progress metrics

## Commits

- `[commit-hash]` test(02-04): Add FileTreeView unit tests
- `[commit-hash]` test(02-04): Add file tree utilities tests
- `[commit-hash]` test(02-04): Add Step1 integration tests
- `[commit-hash]` test(02-04): Add source selection E2E tests
- `[commit-hash]` test(02-04): Add performance benchmarks
- `[commit-hash]` docs(02-04): Update test documentation
```

**Verify**:
- Documentation updated
- Summary created
- Test counts accurate
- Performance metrics documented

**Done when**: Documentation complete and accurate

---

## Verification

**Overall checks after all tasks complete:**

1.  All unit tests pass (`npm run test`)
2.  All E2E tests pass (`npm run test:e2e`)
3.  Test coverage >80% for FileTreeView and utilities
4.  Performance benchmarks met (2000+ files in <200ms)
5.  Virtualization verified (only visible items rendered)
6.  Keyboard navigation tested and working
7.  Accessibility verified (ARIA roles, labels, states)
8.  Edge cases covered (empty folders, special chars, long names)
9.  Documentation updated (README, summary)
10.  No regressions in existing tests

---

## Success Criteria

- [x] FileTreeView unit tests created (45+ tests, >85% coverage)
- [x] File tree utilities tests created (25+ tests, >90% coverage)
- [x] Step1SourceSelection integration tests created (20+ tests, >80% coverage)
- [x] E2E source selection tests created (30+ tests)
- [x] Performance benchmarks created and passing (2000+ files <200ms)
- [x] Keyboard navigation verified
- [x] Accessibility verified (ARIA roles, labels, keyboard support)
- [x] Virtualization verified (VariableSizeList working)
- [x] All tests pass in CI
- [x] Documentation updated
- [x] No regressions in existing tests

---

## Output: SUMMARY.md

When this plan is complete, create `02-04-SUMMARY.md` with actual metrics, test counts, and completion date as shown in Task 6.

---

**Ready to execute**: Run this plan with `/run-plan .planning/phases/02-file-tree-view/02-04-PLAN.md`
