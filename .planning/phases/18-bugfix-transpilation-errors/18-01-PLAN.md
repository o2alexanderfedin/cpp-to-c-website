# Phase 18, Plan 18-01: Investigate and Fix Transpilation Errors

**Phase**: 18 - Bugfix: Transpilation 161/161 Errors
**Plan**: 18-01 - Investigate root cause and implement fix
**Scope**: Diagnose why all 161 files fail transpilation and fix the underlying issue
**Estimate**: 1-2 hours

---

## Objective

Fix the transpilation failure where all 161 files fail with generic "161 errors" message but no specific error details are shown to the user.

**Why**: The UI shows "161 errors" without any diagnostic information, making it impossible to debug. Based on inversion analysis, the most likely failure modes are:
1. Backend service unreachable/down
2. Error messages suppressed/not displayed
3. Wrong adapter being used (WASM workers for backend transpilation)
4. Request batching/rate limiting issues
5. Empty source code being sent

---

## Execution Context

**Files to load before starting:**
- `@src/components/playground/wizard/Step3Transpilation.tsx` - Step 3 UI component
- `@src/components/playground/wizard/controllers/TranspilationController.ts` - Controller orchestrating transpilation
- `@src/adapters/BackendTranspilerAdapter.ts` - Backend HTTP adapter
- `@src/adapters/WasmTranspilerAdapter.ts` - WASM adapter
- `@src/workers/WorkerPoolController.ts` - Worker pool (if being misused for backend)

---

## Context

**Current symptoms (from screenshot):**
- ✅ Parallel Mode shows (7 workers) - indicates worker pool is active
- ❌ 0 successful, 161 errors
- ❌ "Transpilation complete! 0 files processed successfully, 161 errors"
- ❌ 446.0 files/sec (impossibly fast - suggests immediate failure)
- ❌ No specific error messages displayed

**Inversion analysis identified:**
- **Most critical**: Error details are hidden from user
- **Likely cause**: Backend unreachable or wrong adapter being used
- **Secondary**: Worker pool being used for backend transpilation (architectural mismatch)

**Expected behavior:**
- Backend adapter should make HTTP requests to transpiler service
- Worker pool should ONLY be used for WASM transpilation
- Errors should show specific messages per file
- Progress should be realistic (not 446 files/sec)

---

## Tasks

### Task 1: Investigate Error Logging (RESEARCH)
**Type**: research
**Files**: Console, Network tab, Source code

**Action**:
1. **Check browser console for errors**:
   - Open browser DevTools → Console
   - Look for network errors, CORS issues, 404s, 500s
   - Check for JavaScript exceptions
   - Screenshot any relevant errors

2. **Check Network tab**:
   - Open DevTools → Network
   - Filter for XHR/Fetch requests
   - Look for requests to backend transpiler
   - Check status codes (200, 404, 500, etc.)
   - Inspect request/response payloads
   - Screenshot relevant requests

3. **Check adapter selection logic**:
```typescript
// In TranspilationController or similar
// Which adapter is being used?
// Is it BackendTranspilerAdapter or WasmTranspilerAdapter?
```

4. **Check worker pool usage**:
```typescript
// Is WorkerPoolController being invoked for backend transpilation?
// Workers should ONLY be used for WASM
```

**Verify**:
- ✅ Console errors documented
- ✅ Network requests analyzed
- ✅ Adapter selection logic understood
- ✅ Worker pool usage pattern identified

**Expected findings**:
- Backend endpoint URL
- Actual error responses from backend
- Whether CORS is blocking requests
- Whether adapter selection is correct

**Done**: ✅ Root cause identified

---

### Task 2: Check Backend Adapter Implementation
**Type**: investigate
**Files**: `src/adapters/BackendTranspilerAdapter.ts`

**Action**:
1. **Verify error handling**:
```typescript
// Does the adapter properly return error messages?
// Or does it just return success: false without details?

// Look for:
async transpile(source: string, options: TranspileOptions): Promise<TranspileResult> {
  try {
    const response = await fetch(this.apiUrl + '/transpile', {
      method: 'POST',
      headers: { 'Content-Type': 'application/json' },
      body: JSON.stringify({ source, options })
    });

    if (!response.ok) {
      // QUESTION: Is error message extracted and returned?
      const errorData = await response.json();
      return {
        success: false,
        output: '',
        error: errorData.error || `HTTP ${response.status}`, // Is this here?
        diagnostics: []
      };
    }

    return await response.json();
  } catch (err) {
    // QUESTION: Is network error message preserved?
    return {
      success: false,
      output: '',
      error: err.message, // Is this here?
      diagnostics: []
    };
  }
}
```

2. **Check if BackendTranspilerAdapter is being used at all**:
```bash
# Search for where adapter is instantiated
grep -r "BackendTranspilerAdapter" src/
grep -r "WasmTranspilerAdapter" src/
```

3. **Verify API endpoint configuration**:
```typescript
// What is the backend URL?
// Is it hardcoded or from env?
// Is the backend actually running?
```

**Verify**:
- ✅ Error messages are preserved from backend
- ✅ Network errors are captured properly
- ✅ API endpoint is correct
- ✅ Adapter selection logic works

**Done**: ✅ Backend adapter understood

---

### Task 3: Check Step 3 Error Display
**Type**: investigate
**Files**: `src/components/playground/wizard/Step3Transpilation.tsx`

**Action**:
1. **Find where errors are displayed**:
```typescript
// Search for where FILE_ERROR events are handled
// Are error messages being shown or just counts?

// Look for something like:
{results.map((result, idx) => (
  result.error ? (
    <div className="error">{result.error}</div> // Is this showing the actual error?
  ) : null
))}
```

2. **Check if errors array is populated**:
```typescript
// Are individual file errors being tracked?
// Or just a count?
const [errors, setErrors] = useState<string[]>([]); // vs
const [errorCount, setErrorCount] = useState(0); // ???
```

3. **Verify FILE_ERROR event handler**:
```typescript
// When TranspilationController emits FILE_ERROR, is the error message preserved?
controller.on((event) => {
  if (event.type === TranspilationEventType.FILE_ERROR) {
    // Is event.error being captured and displayed?
  }
});
```

**Verify**:
- ✅ Error messages from events are captured
- ✅ UI displays individual error messages (not just counts)
- ✅ Error details are accessible to user

**Done**: ✅ UI error handling understood

---

### Task 4: Test Backend Connectivity
**Type**: verify
**Files**: N/A

**Action**:
1. **Check if backend is running**:
```bash
# Assuming backend runs on localhost:3000 or similar
curl http://localhost:3000/health || echo "Backend not running"
```

2. **Test single file transpilation via curl**:
```bash
curl -X POST http://localhost:3000/transpile \
  -H "Content-Type: application/json" \
  -d '{"source":"int main() { return 0; }","options":{"targetStandard":"c99","includeACSL":false}}'
```

3. **Check backend logs** (if available):
```bash
# Look for backend process
ps aux | grep -i transpile
# Check logs
tail -f /path/to/backend/logs
```

**Verify**:
- ✅ Backend is reachable
- ✅ Backend can transpile successfully
- ✅ Backend returns proper error format

**Expected outcomes**:
- Backend is running: Fix UI to show proper errors
- Backend is NOT running: Show "Backend unavailable" message
- Backend returns errors: Display them in UI

**Done**: ✅ Backend connectivity verified

---

### Task 5: Implement Fix Based on Findings
**Type**: fix
**Files**: TBD based on investigation

**Action**:
Based on investigation findings, implement ONE of:

**Scenario A: Backend is down**
```typescript
// In TranspilationController or adapter
// Add backend health check before starting

async transpile(...) {
  try {
    const healthCheck = await fetch(this.apiUrl + '/health');
    if (!healthCheck.ok) {
      this.emit({
        type: TranspilationEventType.ERROR,
        error: 'Backend transpiler service is unavailable. Please check that the backend server is running.'
      });
      return;
    }
  } catch (err) {
    this.emit({
      type: TranspilationEventType.ERROR,
      error: 'Cannot reach backend transpiler service. Please ensure the backend server is running and accessible.'
    });
    return;
  }

  // Continue with transpilation...
}
```

**Scenario B: Error messages are suppressed**
```typescript
// In Step3Transpilation.tsx
// Add error details display

<div className="error-list">
  <h3>Errors ({errors.length})</h3>
  {errors.map((error, idx) => (
    <div key={idx} className="error-item">
      <strong>{error.fileName}</strong>
      <p>{error.message}</p>
    </div>
  ))}
</div>
```

**Scenario C: Wrong adapter being used**
```typescript
// Ensure worker pool is ONLY used for WASM
if (this.executionMode === 'parallel' && this.workerPool && this.adapterType === 'wasm') {
  await this.transpileParallel(...);
} else {
  await this.transpileSequential(...); // Use backend adapter sequentially
}
```

**Scenario D: All files have empty source**
```typescript
// Add validation before transpiling
const fileHandle = await file.handle.getFile();
const content = await fileHandle.text();

if (!content || content.trim().length === 0) {
  this.emit({
    type: TranspilationEventType.FILE_ERROR,
    filePath: file.path,
    error: 'File is empty or cannot be read'
  });
  continue;
}
```

**Verify**:
- ✅ Fix addresses root cause identified in investigation
- ✅ Error messages are now visible to user
- ✅ TypeScript compiles without errors
- ✅ No new issues introduced

**Done**: ✅ Fix implemented

---

### Task 6: Add Error Details UI (if needed)
**Type**: create/update
**Files**: `src/components/playground/wizard/Step3Transpilation.tsx`

**Action**:
If error details aren't currently shown, add a collapsible error list:

```typescript
// Add state for error details
const [fileErrors, setFileErrors] = useState<Array<{fileName: string, error: string}>>([]);
const [showErrorDetails, setShowErrorDetails] = useState(false);

// Update event handler
useEffect(() => {
  const handleEvent = (event: TranspilationEvent) => {
    if (event.type === TranspilationEventType.FILE_ERROR) {
      setFileErrors(prev => [...prev, {
        fileName: event.fileName || event.filePath || 'Unknown',
        error: event.error || event.result?.error || 'Unknown error'
      }]);
    }
  };

  controller.on(handleEvent);
  return () => controller.off(handleEvent);
}, [controller]);

// Add UI
{fileErrors.length > 0 && (
  <div className="error-section">
    <button onClick={() => setShowErrorDetails(!showErrorDetails)}>
      {showErrorDetails ? 'Hide' : 'Show'} Error Details ({fileErrors.length} files)
    </button>

    {showErrorDetails && (
      <div className="error-list">
        {fileErrors.map((err, idx) => (
          <div key={idx} className="error-item">
            <code>{err.fileName}</code>
            <p>{err.error}</p>
          </div>
        ))}
      </div>
    )}
  </div>
)}
```

**Verify**:
- ✅ Error details are collapsible
- ✅ Shows file name and specific error message
- ✅ Styled consistently with rest of UI
- ✅ Accessible (keyboard navigation, ARIA labels)

**Done**: ✅ Error details UI added

---

### Task 7: Write Tests for Error Handling
**Type**: test
**Files**: `src/components/playground/wizard/Step3Transpilation.test.tsx`, `src/adapters/BackendTranspilerAdapter.test.ts`

**Action**:
Add tests for error scenarios:

```typescript
// Test backend unavailable error
it('shows backend unavailable message when service is down', async () => {
  // Mock fetch to fail
  global.fetch = vi.fn().mockRejectedValue(new Error('Network error'));

  render(<Step3Transpilation ... />);

  // Start transpilation
  fireEvent.click(screen.getByText('Start Transpilation'));

  await waitFor(() => {
    expect(screen.getByText(/backend.*unavailable/i)).toBeInTheDocument();
  });
});

// Test error details display
it('displays individual file errors when transpilation fails', async () => {
  // Mock controller to emit file errors
  const mockController = {
    on: vi.fn((handler) => {
      handler({
        type: TranspilationEventType.FILE_ERROR,
        fileName: 'test.cpp',
        error: 'Syntax error on line 5'
      });
    }),
    off: vi.fn(),
    transpile: vi.fn()
  };

  render(<Step3Transpilation controller={mockController} ... />);

  // Should show error details
  expect(screen.getByText('test.cpp')).toBeInTheDocument();
  expect(screen.getByText(/Syntax error on line 5/)).toBeInTheDocument();
});
```

**Verify**:
- ✅ Backend unavailable scenario tested
- ✅ Error display tested
- ✅ All new tests passing
- ✅ Existing tests still pass

**Done**: ✅ Tests added

---

### Task 8: Manual Verification
**Type**: verify
**Files**: N/A

**Action**:
1. **Test with backend running**:
   - Start backend service
   - Run transpilation
   - Verify success case works

2. **Test with backend stopped**:
   - Stop backend service
   - Run transpilation
   - Verify clear error message: "Backend unavailable"

3. **Test with invalid C++ code**:
   - Create file with syntax errors
   - Run transpilation
   - Verify specific error messages shown

4. **Test with empty files**:
   - Create empty .cpp files
   - Run transpilation
   - Verify appropriate error message

**Verify**:
- ✅ Backend unavailable message is clear
- ✅ Error details are accessible
- ✅ UI doesn't show generic "161 errors" anymore
- ✅ Each error has file name and message
- ✅ User can debug their transpilation issues

**Done**: ✅ Manual verification complete

---

## Verification

**Overall checks after all tasks complete:**

1. ✅ Root cause identified and documented
2. ✅ Fix implemented and tested
3. ✅ Error messages are now visible to users
4. ✅ Backend connectivity check added (if needed)
5. ✅ Error details UI shows file-specific messages
6. ✅ Tests added for error scenarios
7. ✅ All tests passing
8. ✅ TypeScript compiles without errors
9. ✅ Manual testing confirms fix works
10. ✅ No regression in success case

---

## Success Criteria

- [x] Root cause of 161 errors identified
- [x] Error messages are now displayed (not hidden)
- [x] Backend connectivity issues handled gracefully
- [x] UI shows specific error per file
- [x] Collapsible error details added
- [x] Tests cover error scenarios
- [x] All tests passing
- [x] Manual verification confirms fix
- [x] No generic "X errors" messages anymore

---

## Output: SUMMARY.md

When this plan is complete, create `18-01-SUMMARY.md` with:
- Root cause analysis
- Fix implemented
- Files modified
- Test results
- Manual verification results
- Screenshots (before/after)
- Commit hash

---

**Ready to execute**: Run this plan with `/run-plan .planning/phases/18-bugfix-transpilation-errors/18-01-PLAN.md`
