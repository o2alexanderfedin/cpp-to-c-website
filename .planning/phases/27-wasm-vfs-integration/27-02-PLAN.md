# Phase 27, Plan 27-02: Include Path Support for Virtual Files

**Phase**: 27 - WASM VFS Integration
**Plan**: 27-02 - Multiple Include Directory Support
**Type**: Implementation (Foundation Extension)
**Created**: 2025-12-23

---

## Objective

Add support for multiple include directories (`-I/path1 -I/path2`) to enable standard C++ include patterns with virtual files.

**Success**: C++ code can use `#include <header.h>` instead of absolute paths like `#include "/virtual/include/header.h"`.

**User Requirement**: "Mind that we wanna support multiple header dirs, as normal compilers do."

---

## Context

### Current State (Phase 27-01)
- ‚úÖ Virtual file system working with absolute paths
- ‚úÖ Files resolved via FileContentMappings
- ‚úÖ Must use full paths: `#include "/virtual/stdio.h"`

### The Problem
Standard C++ code uses relative includes:
```cpp
#include <stdio.h>      // Standard library
#include <vector>       // STL
#include "myheader.h"   // Project headers
```

Compilers find these via `-I` flags:
```bash
g++ -I/usr/include -I/project/include main.cpp
```

We need the same for virtual files.

### The Solution
Add `includePaths` to TranspileOptions, automatically add `-I` flags to compiler args:

```cpp
opts.includePaths = {"/usr/include", "/project/include"};
opts.virtualFiles = {
    {"/usr/include/stdio.h", "..."},
    {"/project/include/myheader.h", "..."}
};

// Clang args will include: -I/usr/include -I/project/include
```

---

## Tasks

### Task 1: Update TranspilerAPI.h

**Type**: API Design
**Action**: Add `includePaths` field to TranspileOptions
**Priority**: CRITICAL

**File**: `/Users/alexanderfedin/Projects/hapyy/hupyy-cpp-to-c/include/TranspilerAPI.h`

**Location**: Inside `struct TranspileOptions` (after virtualFiles field)

**Code to Add**:
```cpp
/// @brief Include directories for header file resolution
/// @details Adds -I flags to compiler arguments for each path.
///          Works with both real and virtual file paths.
///          Example: {"/usr/include", "/project/include"}
/// @note Paths are added in order - first path has highest priority
std::vector<std::string> includePaths;
```

**Verification**:
- ‚úÖ Field added after virtualFiles
- ‚úÖ Documentation explains purpose
- ‚úÖ Header compiles without errors
- ‚úÖ No breaking changes to existing API

**Done When**: TranspileOptions has includePaths field with proper documentation

---

### Task 2: Modify TranspilerAPI.cpp to Add Include Flags

**Type**: Implementation
**Action**: Add -I flags to compiler args from includePaths
**Priority**: CRITICAL

**File**: `/Users/alexanderfedin/Projects/hapyy/hupyy-cpp-to-c/src/TranspilerAPI.cpp`

**Location**: Inside `transpile()` function, before runToolOnCodeWithArgs call (around line 220)

**Code to Add** (before building FileContentMappings):
```cpp
// Add include paths as -I arguments
for (const auto& includePath : options.includePaths) {
    args.push_back("-I" + includePath);
}
```

**Verification**:
- ‚úÖ Include paths added to args before Clang invocation
- ‚úÖ Code compiles successfully
- ‚úÖ Existing functionality still works
- ‚úÖ NO placeholders in implementation

**Done When**: Include paths converted to -I flags and passed to Clang

---

### Task 3: Create Unit Tests

**Type**: Testing (PROOF!)
**Action**: Prove include path resolution works
**Priority**: CRITICAL

**File to Create**: `/Users/alexanderfedin/Projects/hapyy/hupyy-cpp-to-c/tests/TranspilerAPI_IncludePaths_Test.cpp`

**Test Cases**:

#### Test 1: Single Include Directory
```cpp
TEST(TranspilerAPI_IncludePaths, SingleIncludeDirectory) {
    cpptoc::TranspileOptions opts;
    opts.includePaths = {"/virtual/include"};
    opts.virtualFiles = {
        {"/virtual/include/test.h", "#define VALUE 42\n"}
    };

    std::string cpp = R"(
        #include <test.h>
        int x = VALUE;
    )";

    auto result = cpptoc::transpile(cpp, "test.cpp", opts);

    EXPECT_TRUE(result.success) << "Should find test.h via include path";
    EXPECT_THAT(result.c, HasSubstr("int x = 42")) << "VALUE should be expanded";
}
```

#### Test 2: Multiple Include Directories with Priority
```cpp
TEST(TranspilerAPI_IncludePaths, MultipleIncludeDirectoriesWithPriority) {
    cpptoc::TranspileOptions opts;
    opts.includePaths = {"/virtual/include1", "/virtual/include2"};
    opts.virtualFiles = {
        {"/virtual/include1/header.h", "#define FROM_INCLUDE1"},
        {"/virtual/include2/other.h", "#define FROM_INCLUDE2"}
    };

    std::string cpp = R"(
        #include <header.h>
        #include <other.h>
    )";

    auto result = cpptoc::transpile(cpp, "test.cpp", opts);

    EXPECT_TRUE(result.success) << "Should find headers in both directories";
}
```

#### Test 3: Include Path Priority (First Wins)
```cpp
TEST(TranspilerAPI_IncludePaths, IncludePathPriority) {
    cpptoc::TranspileOptions opts;
    opts.includePaths = {"/virtual/first", "/virtual/second"};
    opts.virtualFiles = {
        {"/virtual/first/header.h", "#define VALUE 100"},
        {"/virtual/second/header.h", "#define VALUE 200"}
    };

    std::string cpp = R"(
        #include <header.h>
        int x = VALUE;
    )";

    auto result = cpptoc::transpile(cpp, "test.cpp", opts);

    EXPECT_TRUE(result.success) << "Should find header";
    EXPECT_THAT(result.c, HasSubstr("int x = 100")) << "Should use first include path";
}
```

#### Test 4: Quoted vs Angle Bracket Includes
```cpp
TEST(TranspilerAPI_IncludePaths, QuotedVsAngleBracketIncludes) {
    cpptoc::TranspileOptions opts;
    opts.includePaths = {"/virtual/include"};
    opts.virtualFiles = {
        {"/virtual/include/system.h", "#define SYSTEM 1"},
        {"./local.h", "#define LOCAL 2"}
    };

    std::string cpp = R"(
        #include <system.h>
        #include "local.h"
        int x = SYSTEM + LOCAL;
    )";

    auto result = cpptoc::transpile(cpp, "test.cpp", opts);

    EXPECT_TRUE(result.success) << "Should handle both include styles";
    EXPECT_THAT(result.c, HasSubstr("int x = 3")) << "Both macros should expand";
}
```

#### Test 5: Backward Compatibility (No Include Paths)
```cpp
TEST(TranspilerAPI_IncludePaths, BackwardCompatibility) {
    cpptoc::TranspileOptions opts;
    opts.virtualFiles = {
        {"/virtual/absolute.h", "#define ABS 42"}
    };
    // No includePaths set

    std::string cpp = R"(
        #include "/virtual/absolute.h"
        int x = ABS;
    )";

    auto result = cpptoc::transpile(cpp, "test.cpp", opts);

    EXPECT_TRUE(result.success) << "Absolute paths should still work";
    EXPECT_THAT(result.c, HasSubstr("int x = 42"));
}
```

**Build Integration**:
Add to CMakeLists.txt:
```cmake
add_executable(TranspilerAPI_IncludePaths_Test
    tests/TranspilerAPI_IncludePaths_Test.cpp
)
target_link_libraries(TranspilerAPI_IncludePaths_Test
    cpptoc_static
    gtest_main
)
add_test(NAME TranspilerAPI_IncludePaths COMMAND TranspilerAPI_IncludePaths_Test)
```

**Verification**:
- ‚úÖ All tests compile
- ‚úÖ All 5 tests PASS (exit code 0)
- ‚úÖ Single include directory works
- ‚úÖ Multiple directories work
- ‚úÖ Priority order correct
- ‚úÖ Both include styles work
- ‚úÖ Backward compatibility maintained

**Done When**: All 5 tests pass successfully

---

### Task 4: Update Documentation

**Type**: Documentation
**Action**: Document include path feature
**Priority**: MEDIUM

**Files to Update**:

#### 1. README.md
Add to VFS section:
```markdown
### Include Paths

Support for multiple include directories (like `-I` compiler flags):

```cpp
cpptoc::TranspileOptions opts;
opts.includePaths = {"/usr/include/c++/17", "/project/include"};
opts.virtualFiles = {
    {"/usr/include/c++/17/vector", "... STL vector ..."},
    {"/project/include/myheader.h", "... project header ..."}
};

std::string cpp = R"(
    #include <vector>           // Found via /usr/include/c++/17
    #include "myheader.h"       // Found via /project/include
)";

auto result = cpptoc::transpile(cpp, "test.cpp", opts);
```

**Benefits:**
- Standard C++ include syntax (`#include <header>`)
- Multiple include directories
- Priority-based resolution (first path wins)
- Works with both system and project headers
```

#### 2. Phase 27-02 Summary
Create `/Users/alexanderfedin/Projects/hapyy/hupyy-cpp-to-c/website/.planning/phases/27-wasm-vfs-integration/27-02-SUMMARY.md`:
```markdown
# Phase 27-02 Summary: Include Path Support

**Status**: ‚úÖ COMPLETED
**Date**: 2025-12-23

## What Was Implemented

Added multiple include directory support to TranspilerAPI, enabling standard C++ include syntax with virtual files.

## Changes Made

### API Changes
- Added `includePaths` field to `TranspileOptions`
- Type: `std::vector<std::string>`

### Implementation Changes
- Modified `transpile()` to add -I flags from includePaths
- ~3 lines of implementation code

### Test Suite
- 5 comprehensive tests covering all scenarios
- All tests PASSING

## Code Statistics
- **API additions**: 4 lines
- **Implementation additions**: 3 lines
- **Total functional code**: 7 lines
- **NO placeholders**: ‚úÖ
- **NO TODO markers**: ‚úÖ

## Test Results
All 5 tests PASSED ‚úÖ

## Next Steps
Phase 27-03: WASM Bindings Update
```

**Done When**: All documentation updated

---

### Task 5: Commit Changes

**Type**: Git
**Action**: Commit include path support
**Priority**: HIGH

**Git Workflow**:

```bash
cd /Users/alexanderfedin/Projects/hapyy/hupyy-cpp-to-c

# Ensure on develop branch
git checkout develop

# Stage changes
git add include/TranspilerAPI.h
git add src/TranspilerAPI.cpp
git add tests/TranspilerAPI_IncludePaths_Test.cpp
git add CMakeLists.txt
git add README.md
git add website/.planning/phases/27-wasm-vfs-integration/27-02-SUMMARY.md

# Commit
git commit -m "$(cat <<'EOF'
feat(27-02): Add include path support for virtual files

FEATURE: Multiple include directory support (-I flags)

What Was Implemented:
- Added includePaths field to TranspileOptions
- Automatically adds -I flags to compiler arguments
- Enables standard C++ include syntax with virtual files
- Priority-based resolution (first path wins)

API Changes:
- TranspileOptions::includePaths (vector of directory paths)
- Backward compatible - defaults to empty vector

Implementation:
- 3 lines of code in transpile() function
- Adds -I flag for each includePath before Clang invocation
- Works with both virtual and real file paths

Usage Example:
opts.includePaths = {"/usr/include", "/project"};
opts.virtualFiles = {{"/usr/include/stdio.h", "..."}};
// Can now use: #include <stdio.h>

Testing:
- 5 comprehensive unit tests (all passing)
- Single include directory ‚úÖ
- Multiple directories ‚úÖ
- Priority order ‚úÖ
- Both include styles ‚úÖ
- Backward compatibility ‚úÖ

Code Quality:
- NO placeholders anywhere ‚úÖ
- NO TODO markers ‚úÖ
- 7 lines of implementation code total
- Full documentation included

Files Modified:
- include/TranspilerAPI.h (+4 lines)
- src/TranspilerAPI.cpp (+3 lines)

Files Created:
- tests/TranspilerAPI_IncludePaths_Test.cpp (135 lines)
- website/.planning/phases/27-wasm-vfs-integration/27-02-SUMMARY.md

Why This Matters:
- Enables standard C++ include syntax
- Critical for WASM with standard library headers
- Foundation for Phase 27-04 (stdlib bundle)

Next Phase: 27-03 (WASM Bindings)

Phase: 27-02
Type: Include Path Support
Status: COMPLETE ‚úÖ

ü§ñ Generated with [Claude Code](https://claude.com/claude-code)

Co-Authored-By: Claude Sonnet 4.5 <noreply@anthropic.com>
EOF
)"

# Push to origin
git push origin develop
```

**Verification**:
- ‚úÖ All changes committed
- ‚úÖ Descriptive commit message
- ‚úÖ Pushed to origin/develop

**Done When**: Changes committed and pushed

---

## Success Criteria

### ‚úÖ Code Quality
- [ ] includePaths field added to TranspileOptions
- [ ] -I flags added to compiler args
- [ ] NO placeholders anywhere
- [ ] NO TODO markers
- [ ] Clean, maintainable code

### ‚úÖ Functionality
- [ ] Single include directory works
- [ ] Multiple include directories work
- [ ] Priority order correct (first wins)
- [ ] Both `<header>` and `"header"` styles work
- [ ] Backward compatible (absolute paths still work)

### ‚úÖ Testing
- [ ] 5 unit tests created
- [ ] All tests PASS (exit code 0)
- [ ] All existing tests still pass
- [ ] NO regressions

### ‚úÖ Documentation
- [ ] API documented in header
- [ ] README updated with examples
- [ ] Phase summary created
- [ ] Usage examples provided

### ‚úÖ Git
- [ ] All changes committed
- [ ] Descriptive commit message
- [ ] Pushed to origin/develop

---

## Verification Commands

```bash
# 1. Build the library
cd /Users/alexanderfedin/Projects/hapyy/hupyy-cpp-to-c
cmake --build build_working --target cpptoc_static

# 2. Build tests
cmake --build build_working --target TranspilerAPI_IncludePaths_Test

# 3. Run include path tests
./build_working/tests/TranspilerAPI_IncludePaths_Test

# Expected: All 5 tests PASS

# 4. Run all tests
cd build_working
ctest --output-on-failure

# Expected: All tests PASS (including VFS tests from 27-01)

# 5. Check for placeholders
grep -r "placeholder" include/TranspilerAPI.h src/TranspilerAPI.cpp && echo "‚ùå FOUND!" || echo "‚úÖ Clean"

# 6. Verify git
git log -1 --oneline
git status
```

---

## Output

After this phase:

1. **Standard Include Syntax**: Can use `#include <header>` instead of absolute paths
2. **Multiple Directories**: Support multiple include paths with priority
3. **Production Quality**: NO placeholders, fully tested
4. **Backward Compatible**: Existing code continues to work
5. **Foundation for WASM**: Ready for stdlib header bundle (Phase 27-04)

**Scope**: 7 lines of implementation code
**Complexity**: Low (simple arg manipulation)
**Risk**: Low (non-breaking addition)
**Time Estimate**: 1 hour

---

**Status**: üìã Plan Ready for Execution
**Dependencies**: Phase 27-01 (VFS) ‚úÖ Complete
**Blocks**: Phase 27-04 (needs include paths for stdlib)
