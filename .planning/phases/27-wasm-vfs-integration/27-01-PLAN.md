# Phase 27, Plan 27-01: Core VFS Integration

**Phase**: 27 - WASM VFS Integration
**Plan**: 27-01 - Core Virtual File System Support
**Type**: Implementation (Minimal, Foundation)
**Created**: 2025-12-22

---

## Objective

Add Virtual File System support to TranspilerAPI using Clang's built-in `FileContentMappings` mechanism.

**Success**: C++ code with `#include` directives successfully resolves virtual header files through in-memory VFS.

**User Requirement**: "We provide it with the virtual file system, and this is it" - VFS responds to Clang's file read requests on-demand.

---

## Context

### Current State (Phase 25)
- ‚úÖ TranspilerAPI.h - Clean library interface (132 lines)
- ‚úÖ TranspilerAPI.cpp - REAL Clang LibTooling implementation (329 lines)
- ‚úÖ `transpile()` function uses `runToolOnCodeWithArgs()` at line 221
- ‚úÖ NO placeholders anywhere

### The Problem
When C++ code contains `#include "header.h"`, Clang needs to read the header file. Currently it reads from disk, but for WASM we need in-memory VFS.

### The Solution (Discovered via Research)
Clang's `runToolOnCodeWithArgs()` already has VFS support via the `FileContentMappings` parameter:

```cpp
bool runToolOnCodeWithArgs(
    std::unique_ptr<FrontendAction> ToolAction,
    const Twine &Code,
    const std::vector<std::string> &Args,
    const Twine &FileName,
    const Twine &ToolName = "clang-tool",
    std::shared_ptr<PCHContainerOperations> PCHContainerOps = std::make_shared<PCHContainerOperations>(),
    const FileContentMappings &VirtualMappedFiles = FileContentMappings()
);
```

**Key Insight**: We just need to populate `VirtualMappedFiles` - Clang handles the rest!

---

## Tasks

### Task 1: Update TranspilerAPI.h

**Type**: API Design
**Action**: Add `virtualFiles` field to TranspileOptions
**Priority**: CRITICAL

**File**: `/Users/alexanderfedin/Projects/hapyy/hupyy-cpp-to-c/include/TranspilerAPI.h`

**Location**: Inside `struct TranspileOptions` (around line 40)

**Code to Add**:
```cpp
/// @brief Virtual files for in-memory compilation
/// @details Each pair represents (file_path, file_content).
///          Used to provide header files without filesystem access.
///          Example: {"/usr/include/stdio.h", "... header content ..."}
/// @note Paths should be absolute and match -I include directories
std::vector<std::pair<std::string, std::string>> virtualFiles;
```

**Verification**:
- ‚úÖ Field added to TranspileOptions struct
- ‚úÖ Documentation explains purpose and format
- ‚úÖ Header compiles without errors
- ‚úÖ No breaking changes to existing API

**Done When**: TranspileOptions has virtualFiles field with proper documentation

---

### Task 2: Modify TranspilerAPI.cpp to Use Virtual Files

**Type**: Implementation
**Action**: Build FileContentMappings and pass to runToolOnCodeWithArgs
**Priority**: CRITICAL

**File**: `/Users/alexanderfedin/Projects/hapyy/hupyy-cpp-to-c/src/TranspilerAPI.cpp`

**Location**: Inside `transpile()` function, before line 221

**Code Changes**:

**Before** (lines 221-226):
```cpp
bool success = clang::tooling::runToolOnCodeWithArgs(
    factory.create(),
    cppSource,
    args,
    filename
);
```

**After** (add before runToolOnCodeWithArgs call):
```cpp
// Build FileContentMappings from virtual files
clang::tooling::FileContentMappings virtualMappedFiles;
for (const auto& [path, content] : options.virtualFiles) {
    virtualMappedFiles.push_back({path, content});
}

// Run with virtual files support
bool success = clang::tooling::runToolOnCodeWithArgs(
    factory.create(),
    cppSource,
    args,
    filename,
    "cpptoc-transpiler",  // tool name
    std::make_shared<clang::PCHContainerOperations>(),
    virtualMappedFiles  // virtual files
);
```

**Verification**:
- ‚úÖ Code compiles successfully
- ‚úÖ Virtual files are passed to Clang
- ‚úÖ Existing functionality still works (backward compatible)
- ‚úÖ NO placeholders in implementation

**Done When**: TranspilerAPI.cpp builds FileContentMappings and passes them to Clang

---

### Task 3: Create Unit Tests

**Type**: Testing (PROOF!)
**Action**: Prove virtual file resolution works
**Priority**: CRITICAL

**File to Create**: `/Users/alexanderfedin/Projects/hapyy/hupyy-cpp-to-c/tests/TranspilerAPI_VirtualFiles_Test.cpp`

**Test Cases**:

#### Test 1: Single Virtual Header File
```cpp
TEST(TranspilerAPI, VirtualFileResolution_SingleHeader) {
    cpptoc::TranspileOptions opts;
    opts.virtualFiles = {
        {"/virtual/test.h", "#define MACRO 42\n"}
    };

    std::string cpp = R"(
        #include "/virtual/test.h"
        int x = MACRO;
    )";

    auto result = cpptoc::transpile(cpp, "test.cpp", opts);

    EXPECT_TRUE(result.success) << "Transpilation should succeed";
    EXPECT_THAT(result.c, HasSubstr("int x = 42")) << "MACRO should be expanded";
    EXPECT_THAT(result.c, Not(HasSubstr("MACRO"))) << "Macro name should not appear";
}
```

#### Test 2: Multiple Virtual Headers
```cpp
TEST(TranspilerAPI, VirtualFileResolution_MultipleHeaders) {
    cpptoc::TranspileOptions opts;
    opts.virtualFiles = {
        {"/virtual/a.h", "int foo();"},
        {"/virtual/b.h", "int bar();"}
    };

    std::string cpp = R"(
        #include "/virtual/a.h"
        #include "/virtual/b.h"
        int main() { return foo() + bar(); }
    )";

    auto result = cpptoc::transpile(cpp, "test.cpp", opts);

    EXPECT_TRUE(result.success) << "Transpilation should succeed";
    EXPECT_THAT(result.c, HasSubstr("foo")) << "Should have foo function";
    EXPECT_THAT(result.c, HasSubstr("bar")) << "Should have bar function";
}
```

#### Test 3: Nested Includes
```cpp
TEST(TranspilerAPI, VirtualFileResolution_NestedIncludes) {
    cpptoc::TranspileOptions opts;
    opts.virtualFiles = {
        {"/virtual/base.h", "#define VALUE 100"},
        {"/virtual/derived.h", "#include \"/virtual/base.h\"\n#define DOUBLE (VALUE * 2)"}
    };

    std::string cpp = R"(
        #include "/virtual/derived.h"
        int x = DOUBLE;
    )";

    auto result = cpptoc::transpile(cpp, "test.cpp", opts);

    EXPECT_TRUE(result.success) << "Nested includes should work";
    EXPECT_THAT(result.c, HasSubstr("int x = 200")) << "Nested macros should expand";
}
```

#### Test 4: Missing Virtual File (Error Handling)
```cpp
TEST(TranspilerAPI, VirtualFileResolution_MissingFile) {
    cpptoc::TranspileOptions opts;
    // No virtual files provided

    std::string cpp = R"(
        #include "/virtual/missing.h"
        int x = 42;
    )";

    auto result = cpptoc::transpile(cpp, "test.cpp", opts);

    EXPECT_FALSE(result.success) << "Should fail with missing file";
    EXPECT_GT(result.diagnostics.size(), 0) << "Should have error diagnostics";
}
```

#### Test 5: Empty Virtual Files List (Backward Compatibility)
```cpp
TEST(TranspilerAPI, VirtualFileResolution_EmptyVirtualFiles) {
    cpptoc::TranspileOptions opts;
    opts.virtualFiles = {};  // Empty, no virtual files

    std::string cpp = "int add(int a, int b) { return a + b; }";

    auto result = cpptoc::transpile(cpp, "test.cpp", opts);

    EXPECT_TRUE(result.success) << "Should work with no virtual files";
    EXPECT_THAT(result.c, HasSubstr("int add")) << "Should transpile normally";
}
```

**Build Integration**:
Add to CMakeLists.txt:
```cmake
add_executable(TranspilerAPI_VirtualFiles_Test
    tests/TranspilerAPI_VirtualFiles_Test.cpp
)
target_link_libraries(TranspilerAPI_VirtualFiles_Test
    cpptoc_static
    gtest_main
)
add_test(NAME TranspilerAPI_VirtualFiles COMMAND TranspilerAPI_VirtualFiles_Test)
```

**Verification**:
- ‚úÖ All tests compile
- ‚úÖ All tests PASS (exit code 0)
- ‚úÖ Single header resolution works
- ‚úÖ Multiple headers work
- ‚úÖ Nested includes work
- ‚úÖ Missing files fail gracefully
- ‚úÖ Backward compatibility maintained

**Done When**: All 5 tests pass successfully

---

### Task 4: Manual Integration Test

**Type**: Manual Testing
**Action**: Verify end-to-end with realistic C++ code
**Priority**: HIGH

**Test Code** (run via CLI tool):

Create `/tmp/test_vfs.cpp`:
```cpp
#include "/virtual/math_utils.h"

int main() {
    return square(5) + cube(3);
}
```

Create test driver:
```cpp
#include "TranspilerAPI.h"
#include <iostream>

int main() {
    cpptoc::TranspileOptions opts;

    // Virtual header with inline functions
    opts.virtualFiles = {
        {"/virtual/math_utils.h", R"(
            inline int square(int x) { return x * x; }
            inline int cube(int x) { return x * x * x; }
        )"}
    };

    std::string cpp = R"(
        #include "/virtual/math_utils.h"
        int main() {
            return square(5) + cube(3);
        }
    )";

    auto result = cpptoc::transpile(cpp, "test.cpp", opts);

    if (result.success) {
        std::cout << "=== TRANSPILATION SUCCESS ===" << std::endl;
        std::cout << result.c << std::endl;
    } else {
        std::cout << "=== TRANSPILATION FAILED ===" << std::endl;
        for (const auto& diag : result.diagnostics) {
            std::cout << diag.message << std::endl;
        }
    }

    return result.success ? 0 : 1;
}
```

**Expected Output**:
- Transpilation succeeds
- Generated C code contains `square` and `cube` function implementations
- NO placeholder text
- NO "file not found" errors

**Verification**:
- ‚úÖ Integration test runs
- ‚úÖ Virtual files resolve correctly
- ‚úÖ Inline functions inlined or emitted
- ‚úÖ Output is valid C code
- ‚úÖ NO errors or warnings

**Done When**: Integration test produces valid C code

---

### Task 5: Update Build System

**Type**: Build Configuration
**Action**: Ensure TranspilerAPI builds with updated code
**Priority**: MEDIUM

**Files to Check**:
- `/Users/alexanderfedin/Projects/hapyy/hupyy-cpp-to-c/CMakeLists.txt`
- `/Users/alexanderfedin/Projects/hapyy/hupyy-cpp-to-c/src/CMakeLists.txt`

**Actions**:
1. Rebuild transpiler library:
   ```bash
   cd /Users/alexanderfedin/Projects/hapyy/hupyy-cpp-to-c
   cmake --build build_working --target cpptoc_static
   ```

2. Rebuild CLI tool:
   ```bash
   cmake --build build_working --target cpptoc
   ```

3. Run existing test suite:
   ```bash
   cd build_working
   ctest --output-on-failure
   ```

**Verification**:
- ‚úÖ Library builds successfully
- ‚úÖ CLI tool builds successfully
- ‚úÖ All existing tests still pass
- ‚úÖ NO new compiler warnings
- ‚úÖ NO linker errors

**Done When**: Clean build with all tests passing

---

### Task 6: Code Review

**Type**: Quality Assurance
**Action**: Review changes for quality and correctness
**Priority**: HIGH

**Review Checklist**:

#### Code Quality
- [ ] NO placeholders anywhere
- [ ] NO TODO markers
- [ ] Code follows existing style
- [ ] Proper error handling
- [ ] Memory safety (no leaks)
- [ ] Thread safety (if applicable)

#### API Design
- [ ] Backward compatible (old code still works)
- [ ] Clear documentation
- [ ] Intuitive usage
- [ ] Follows SOLID principles

#### Implementation
- [ ] Uses Clang API correctly
- [ ] Efficient (no unnecessary copies)
- [ ] Robust error handling
- [ ] Proper resource cleanup

#### Testing
- [ ] All tests pass
- [ ] Edge cases covered
- [ ] Error cases tested
- [ ] Realistic scenarios tested

**Done When**: All checklist items verified

---

### Task 7: Documentation

**Type**: Documentation
**Action**: Document the new VFS feature
**Priority**: MEDIUM

**Files to Update**:

#### 1. TranspilerAPI.h (Already has docstrings from Task 1)
Ensure comprehensive documentation:
```cpp
/// @brief Virtual files for in-memory compilation
/// @details Provides header files to Clang without filesystem access.
///          Each pair represents (absolute_path, file_content).
///          Clang resolves #include directives through this virtual filesystem.
/// @example
///     opts.virtualFiles = {
///         {"/usr/include/stdio.h", "..."},
///         {"/project/myheader.h", "..."}
///     };
/// @note Paths must be absolute and should match -I include directories
std::vector<std::pair<std::string, std::string>> virtualFiles;
```

#### 2. README.md Update
Add section to `/Users/alexanderfedin/Projects/hapyy/hupyy-cpp-to-c/README.md`:
```markdown
## Virtual File System Support

The transpiler supports in-memory header files via Virtual File System (VFS):

### Usage Example

```cpp
#include "TranspilerAPI.h"

cpptoc::TranspileOptions opts;
opts.virtualFiles = {
    {"/virtual/myheader.h", "#define MACRO 42"}
};

std::string cpp = R"(
    #include "/virtual/myheader.h"
    int x = MACRO;
)";

auto result = cpptoc::transpile(cpp, "test.cpp", opts);
// result.c contains: int x = 42;
```

### How It Works

- Virtual files are provided as (path, content) pairs
- Clang resolves `#include` directives through the VFS
- Files are loaded on-demand (not pre-loaded into memory)
- Supports nested includes
```

#### 3. Phase 27-01 Summary
Create `/Users/alexanderfedin/Projects/hapyy/hupyy-cpp-to-c/website/.planning/phases/27-wasm-vfs-integration/27-01-SUMMARY.md`:
```markdown
# Phase 27-01 Summary: Core VFS Integration

**Status**: ‚úÖ COMPLETED
**Date**: 2025-12-22

## What Was Implemented

Added Virtual File System support to TranspilerAPI using Clang's FileContentMappings.

## Changes Made

### API Changes
- Added `virtualFiles` field to TranspileOptions (TranspilerAPI.h)
- Type: `std::vector<std::pair<std::string, std::string>>`

### Implementation Changes
- Modified `transpile()` to build FileContentMappings (TranspilerAPI.cpp)
- Updated `runToolOnCodeWithArgs()` call to include virtual files

### Code Added
- ~15 lines of implementation code
- 5 comprehensive unit tests
- Documentation and examples

## Test Results

All tests PASSED:
- ‚úÖ Single virtual header resolution
- ‚úÖ Multiple virtual headers
- ‚úÖ Nested includes
- ‚úÖ Error handling (missing files)
- ‚úÖ Backward compatibility

## Verification

- NO placeholders anywhere ‚úÖ
- NO TODO markers ‚úÖ
- All existing tests still pass ‚úÖ
- Clean build with no warnings ‚úÖ

## Next Steps

Phase 27-02: Add multiple include directory support (-I flags)
```

**Done When**: All documentation updated and complete

---

### Task 8: Commit Changes

**Type**: Git
**Action**: Commit VFS integration work
**Priority**: HIGH

**Git Workflow**:

```bash
cd /Users/alexanderfedin/Projects/hapyy/hupyy-cpp-to-c

# Ensure on develop branch
git checkout develop

# Stage changes
git add include/TranspilerAPI.h
git add src/TranspilerAPI.cpp
git add tests/TranspilerAPI_VirtualFiles_Test.cpp
git add website/.planning/phases/27-wasm-vfs-integration/
git add README.md

# Commit with detailed message
git commit -m "$(cat <<'EOF'
feat(27-01): Add Virtual File System support to TranspilerAPI

FEATURE: In-memory header file resolution for WASM usage

What Was Implemented:
- Added virtualFiles field to TranspileOptions
- Modified transpile() to use Clang's FileContentMappings
- Virtual files passed to runToolOnCodeWithArgs()
- Clang resolves #include directives through VFS

API Changes:
- TranspileOptions::virtualFiles (vector of path/content pairs)
- Backward compatible - existing code unaffected

Implementation:
- Uses Clang's built-in VFS support (FileContentMappings)
- On-demand file loading (not pre-loaded)
- Supports nested includes
- Graceful error handling for missing files

Testing:
- 5 comprehensive unit tests (all passing)
- Single header resolution ‚úÖ
- Multiple headers ‚úÖ
- Nested includes ‚úÖ
- Missing file errors ‚úÖ
- Backward compatibility ‚úÖ

Code Quality:
- NO placeholders anywhere ‚úÖ
- NO TODO markers ‚úÖ
- ~15 lines of implementation code
- Full documentation included

Files Modified:
- include/TranspilerAPI.h (+7 lines)
- src/TranspilerAPI.cpp (+8 lines)

Files Created:
- tests/TranspilerAPI_VirtualFiles_Test.cpp (180 lines)
- website/.planning/phases/27-wasm-vfs-integration/27-01-SUMMARY.md

Why This Matters:
- Enables WASM usage (no filesystem access)
- Foundation for browser-based transpilation
- Production-quality implementation (not placeholder)

Next Phase: 27-02 (Multiple include directory support)

Phase: 27-01
Type: Core VFS Integration
Status: COMPLETE ‚úÖ

ü§ñ Generated with [Claude Code](https://claude.com/claude-code)

Co-Authored-By: Claude Sonnet 4.5 <noreply@anthropic.com>
EOF
)"

# Push to origin
git push origin develop
```

**Verification**:
- ‚úÖ All changes committed
- ‚úÖ Descriptive commit message
- ‚úÖ Pushed to origin/develop
- ‚úÖ NO uncommitted changes remain

**Done When**: Changes committed and pushed successfully

---

## Success Criteria

### ‚úÖ Code Quality
- [ ] Virtual files field added to TranspileOptions
- [ ] FileContentMappings built correctly
- [ ] Passed to runToolOnCodeWithArgs()
- [ ] NO placeholders anywhere
- [ ] NO TODO markers
- [ ] Clean, maintainable code

### ‚úÖ Functionality
- [ ] Single virtual header resolves correctly
- [ ] Multiple virtual headers work
- [ ] Nested includes work
- [ ] Missing files fail gracefully
- [ ] Backward compatible (existing code works)

### ‚úÖ Testing (THE PROOF!)
- [ ] 5 unit tests created
- [ ] All tests PASS (exit code 0)
- [ ] Integration test runs successfully
- [ ] All existing tests still pass
- [ ] NO regressions

### ‚úÖ Build System
- [ ] Library builds successfully
- [ ] CLI tool builds successfully
- [ ] NO compiler warnings
- [ ] NO linker errors
- [ ] Clean build

### ‚úÖ Documentation
- [ ] API documented in header
- [ ] README updated with examples
- [ ] Phase summary created
- [ ] Usage examples provided

### ‚úÖ Git
- [ ] All changes committed
- [ ] Descriptive commit message
- [ ] Pushed to origin/develop
- [ ] Clean working directory

---

## Verification Commands

```bash
# 1. Build the library
cd /Users/alexanderfedin/Projects/hapyy/hupyy-cpp-to-c
cmake --build build_working --target cpptoc_static

# Expected: Build succeeds

# 2. Build tests
cmake --build build_working --target TranspilerAPI_VirtualFiles_Test

# Expected: Test executable created

# 3. Run VFS tests
./build_working/tests/TranspilerAPI_VirtualFiles_Test

# Expected: All tests PASS

# 4. Run all tests
cd build_working
ctest --output-on-failure

# Expected: All tests PASS

# 5. Check for placeholders
grep -r "placeholder" include/TranspilerAPI.h src/TranspilerAPI.cpp && echo "‚ùå FOUND PLACEHOLDERS!" || echo "‚úÖ No placeholders"

# Expected: ‚úÖ No placeholders

# 6. Check for TODOs
grep -r "TODO" include/TranspilerAPI.h src/TranspilerAPI.cpp && echo "‚ùå FOUND TODOs!" || echo "‚úÖ No TODOs"

# Expected: ‚úÖ No TODOs

# 7. Verify git status
git status

# Expected: Changes committed, working directory clean
```

---

## Output

After this phase, we will have:

1. **Functional VFS Support**: TranspilerAPI can resolve `#include` directives from in-memory virtual files
2. **Proven Implementation**: 5 unit tests verify correct behavior
3. **Production Quality**: NO placeholders, fully implemented
4. **Backward Compatible**: Existing code continues to work
5. **Well Documented**: API docs, README, examples
6. **Foundation for WASM**: Ready for next phase (include directories)

**Scope**: 15 lines of implementation code, ~200 lines of tests
**Complexity**: Low (uses existing Clang API)
**Risk**: Low (non-breaking change)
**Time Estimate**: 1-2 hours

---

**Status**: üìã Plan Ready for Execution
**Next**: Execute tasks 1-8 in order
**Blocked By**: None (ready to start)
