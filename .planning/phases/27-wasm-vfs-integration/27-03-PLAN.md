# Phase 27, Plan 27-03: WASM Bindings for VFS and Include Paths

**Phase**: 27 - WASM VFS Integration
**Plan**: 27-03 - Update Emscripten Bindings for VFS
**Type**: Implementation (WASM Integration)
**Created**: 2025-12-23

---

## Objective

Update WASM bindings to expose virtualFiles and includePaths to JavaScript, enabling browser-based transpilation with in-memory headers.

**Success**: JavaScript can pass virtual files and include paths to WASM transpiler, which correctly maps them to TranspilerAPI.

---

## Context

### Current State (Phase 27-01, 27-02)
- ‚úÖ TranspilerAPI has virtualFiles and includePaths fields
- ‚úÖ C++ library works with virtual file system
- ‚ùå WASM bindings don't expose these fields

### Current WASM Bindings
File: `/Users/alexanderfedin/Projects/hapyy/hupyy-cpp-to-c/wasm/bindings/full.cpp`

**Existing structures**:
- `Diagnostic`, `ACSLOptions`, `TranspileOptions`, `TranspileResult`
- `WASMTranspiler` class that maps WASM ‚Üí Library options
- Embind bindings expose to JavaScript

### What's Missing
VirtualFile support:
```javascript
// JavaScript wants to do this:
const result = transpiler.transpile(cppCode, {
    virtualFiles: [
        { path: "/usr/include/stdio.h", content: "..." },
        { path: "/project/header.h", content: "..." }
    ],
    includePaths: ["/usr/include", "/project"]
});
```

But current bindings don't support virtualFiles or includePaths.

---

## Tasks

### Task 1: Add VirtualFile Struct to WASM Bindings

**Type**: API Design
**Action**: Add VirtualFile struct to bindings/full.cpp
**Priority**: CRITICAL

**File**: `/Users/alexanderfedin/Projects/hapyy/hupyy-cpp-to-c/wasm/bindings/full.cpp`

**Location**: After Diagnostic struct (around line 18)

**Code to Add**:
```cpp
struct VirtualFile {
    std::string path;
    std::string content;
};
```

**Verification**:
- ‚úÖ Struct added to WASM structures section
- ‚úÖ Follows existing naming convention
- ‚úÖ Compiles without errors

**Done When**: VirtualFile struct defined in bindings

---

### Task 2: Update TranspileOptions with VFS Fields

**Type**: Implementation
**Action**: Add virtualFiles and includePaths to WASM TranspileOptions
**Priority**: CRITICAL

**File**: `/Users/alexanderfedin/Projects/hapyy/hupyy-cpp-to-c/wasm/bindings/full.cpp`

**Location**: Inside TranspileOptions struct (around line 36)

**Code to Add**:
```cpp
struct TranspileOptions {
    ACSLOptions acsl;
    std::string target = "c99";
    bool optimize = false;
    bool monomorphizeTemplates = true;
    bool enableExceptions = true;
    std::string exceptionModel = "sjlj";
    bool enableRTTI = true;

    // NEW: VFS support
    std::vector<VirtualFile> virtualFiles;
    std::vector<std::string> includePaths;
};
```

**Verification**:
- ‚úÖ Fields added to TranspileOptions
- ‚úÖ Uses std::vector for arrays
- ‚úÖ Matches TranspilerAPI.h field types (conceptually)
- ‚úÖ Compiles without errors

**Done When**: TranspileOptions has virtualFiles and includePaths fields

---

### Task 3: Map VFS Fields in WASMTranspiler

**Type**: Implementation
**Action**: Map virtualFiles and includePaths from WASM to library
**Priority**: CRITICAL

**File**: `/Users/alexanderfedin/Projects/hapyy/hupyy-cpp-to-c/wasm/bindings/full.cpp`

**Location**: Inside WASMTranspiler::transpile method (after line 73)

**Code to Add** (after mapping other options):
```cpp
// Map virtual files
for (const auto& vf : options.virtualFiles) {
    libOpts.virtualFiles.push_back({vf.path, vf.content});
}

// Map include paths
libOpts.includePaths = options.includePaths;
```

**Verification**:
- ‚úÖ Virtual files mapped to pairs
- ‚úÖ Include paths copied directly
- ‚úÖ Compiles without errors
- ‚úÖ NO placeholders in implementation

**Done When**: VFS fields correctly mapped to library options

---

### Task 4: Add Embind Bindings for VirtualFile

**Type**: Implementation
**Action**: Expose VirtualFile to JavaScript via Embind
**Priority**: CRITICAL

**File**: `/Users/alexanderfedin/Projects/hapyy/hupyy-cpp-to-c/wasm/bindings/full.cpp`

**Location**: Inside EMSCRIPTEN_BINDINGS block (after Diagnostic, around line 138)

**Code to Add**:
```cpp
value_object<VirtualFile>("VirtualFile")
    .field("path", &VirtualFile::path)
    .field("content", &VirtualFile::content);
```

**Verification**:
- ‚úÖ Follows existing Embind pattern
- ‚úÖ Exposes both fields
- ‚úÖ JavaScript can create VirtualFile objects

**Done When**: VirtualFile bound to JavaScript

---

### Task 5: Update TranspileOptions Embind Bindings

**Type**: Implementation
**Action**: Add virtualFiles and includePaths to TranspileOptions bindings
**Priority**: CRITICAL

**File**: `/Users/alexanderfedin/Projects/hapyy/hupyy-cpp-to-c/wasm/bindings/full.cpp`

**Location**: Inside TranspileOptions Embind block (after line 131)

**Code to Add**:
```cpp
value_object<TranspileOptions>("TranspileOptions")
    .field("acsl", &TranspileOptions::acsl)
    .field("target", &TranspileOptions::target)
    .field("optimize", &TranspileOptions::optimize)
    .field("monomorphizeTemplates", &TranspileOptions::monomorphizeTemplates)
    .field("enableExceptions", &TranspileOptions::enableExceptions)
    .field("exceptionModel", &TranspileOptions::exceptionModel)
    .field("enableRTTI", &TranspileOptions::enableRTTI)
    .field("virtualFiles", &TranspileOptions::virtualFiles)      // NEW
    .field("includePaths", &TranspileOptions::includePaths);     // NEW
```

**Verification**:
- ‚úÖ Fields added to bindings
- ‚úÖ JavaScript can access virtualFiles and includePaths
- ‚úÖ Follows existing pattern

**Done When**: TranspileOptions fully exposed to JavaScript

---

### Task 6: Register Vector Types

**Type**: Implementation
**Action**: Register vector types for Embind
**Priority**: CRITICAL

**File**: `/Users/alexanderfedin/Projects/hapyy/hupyy-cpp-to-c/wasm/bindings/full.cpp`

**Location**: After Diagnostic vector registration (line 145)

**Code to Add**:
```cpp
register_vector<Diagnostic>("DiagnosticVector");
register_vector<VirtualFile>("VirtualFileVector");      // NEW
register_vector<std::string>("StringVector");           // NEW
```

**Verification**:
- ‚úÖ Vectors registered
- ‚úÖ JavaScript can pass arrays
- ‚úÖ Compiles without errors

**Done When**: Vector types registered with Embind

---

### Task 7: Update minimal.cpp Bindings (Same Changes)

**Type**: Implementation
**Action**: Apply same changes to minimal build
**Priority**: HIGH

**File**: `/Users/alexanderfedin/Projects/hapyy/hupyy-cpp-to-c/wasm/bindings/minimal.cpp`

**Action**: Copy all changes from full.cpp to minimal.cpp
- Add VirtualFile struct
- Update TranspileOptions
- Map VFS fields in transpile method
- Add Embind bindings
- Register vector types

**Verification**:
- ‚úÖ minimal.cpp has same VFS support as full.cpp
- ‚úÖ Both builds support virtual files
- ‚úÖ Compiles without errors

**Done When**: Both full and minimal bindings updated

---

### Task 8: Test Build

**Type**: Testing
**Action**: Verify WASM builds successfully with new bindings
**Priority**: CRITICAL

**Build Commands**:
```bash
cd /Users/alexanderfedin/Projects/hapyy/hupyy-cpp-to-c/wasm

# Build full version
./scripts/build-full.sh

# Build minimal version
./scripts/build-minimal.sh
```

**Verification**:
- ‚úÖ Full build succeeds
- ‚úÖ Minimal build succeeds
- ‚úÖ No Emscripten errors
- ‚úÖ WASM files generated
- ‚úÖ JavaScript glue code generated

**Done When**: Both WASM builds successful

---

### Task 9: Update TypeScript Definitions

**Type**: TypeScript
**Action**: Update TypeScript definitions for new VFS fields
**Priority**: HIGH

**File**: `/Users/alexanderfedin/Projects/hapyy/hupyy-cpp-to-c/wasm/glue/src/types.ts`

**Code to Update**:
```typescript
export interface VirtualFile {
    path: string;
    content: string;
}

export interface TranspileOptions {
    acsl?: ACSLOptions;
    target?: string;
    optimize?: boolean;
    monomorphizeTemplates?: boolean;
    enableExceptions?: boolean;
    exceptionModel?: string;
    enableRTTI?: boolean;

    // VFS support
    virtualFiles?: VirtualFile[];
    includePaths?: string[];
}
```

**Verification**:
- ‚úÖ TypeScript definitions match C++ structs
- ‚úÖ Optional fields (?)
- ‚úÖ Array types correct
- ‚úÖ Compiles without TS errors

**Done When**: TypeScript definitions updated

---

### Task 10: Create Manual Test

**Type**: Testing
**Action**: Create Node.js test to verify VFS works via WASM
**Priority**: HIGH

**File to Create**: `/Users/alexanderfedin/Projects/hapyy/hupyy-cpp-to-c/wasm/test/test-vfs.js`

**Test Code**:
```javascript
#!/usr/bin/env node

const createCppToC = require('../glue/dist/full/cpptoc.js');

createCppToC().then(Module => {
    console.log('WASM Module loaded');

    const transpiler = new Module.Transpiler();

    // Test 1: Virtual file with include path
    console.log('\n--- Test 1: Virtual File with Include Path ---');
    const options = new Module.TranspileOptions();

    // Add virtual files
    const virtualFiles = new Module.VirtualFileVector();
    const vf = new Module.VirtualFile();
    vf.path = "/virtual/test.h";
    vf.content = "#define MAGIC 42\n";
    virtualFiles.push_back(vf);
    options.virtualFiles = virtualFiles;

    // Add include paths
    const includePaths = new Module.StringVector();
    includePaths.push_back("/virtual");
    options.includePaths = includePaths;

    const cpp = '#include <test.h>\nint x = MAGIC;';
    const result = transpiler.transpile(cpp, options);

    console.log('Success:', result.success);
    console.log('C Code:', result.c);
    console.log('Diagnostics:', result.diagnostics.size());

    if (result.success && result.c.includes('int x = 42')) {
        console.log('‚úÖ Test PASSED - Virtual file resolved!');
        process.exit(0);
    } else {
        console.log('‚ùå Test FAILED - Virtual file not resolved');
        process.exit(1);
    }

}).catch(err => {
    console.error('‚ùå WASM load failed:', err);
    process.exit(1);
});
```

**Run Test**:
```bash
cd /Users/alexanderfedin/Projects/hapyy/hupyy-cpp-to-c/wasm
node test/test-vfs.js
```

**Verification**:
- ‚úÖ WASM module loads
- ‚úÖ Can create VirtualFile objects
- ‚úÖ Can create vectors
- ‚úÖ Virtual file resolves correctly
- ‚úÖ Test passes (exit code 0)

**Done When**: Manual test passes

---

### Task 11: Documentation

**Type**: Documentation
**Action**: Document WASM VFS usage
**Priority**: MEDIUM

**File to Update**: `/Users/alexanderfedin/Projects/hapyy/hupyy-cpp-to-c/wasm/README.md`

**Section to Add**:
```markdown
## Virtual File System (VFS) Support

The WASM transpiler supports in-memory header files:

### JavaScript/TypeScript Usage

```typescript
import createCppToC from './cpptoc.js';

const Module = await createCppToC();
const transpiler = new Module.Transpiler();

// Create virtual files
const virtualFiles = new Module.VirtualFileVector();
virtualFiles.push_back({
    path: "/usr/include/stdio.h",
    content: "... header content ..."
});

// Create include paths
const includePaths = new Module.StringVector();
includePaths.push_back("/usr/include");

// Transpile with VFS
const options = new Module.TranspileOptions();
options.virtualFiles = virtualFiles;
options.includePaths = includePaths;

const result = transpiler.transpile(cppCode, options);
```

### Why This Matters

- **Browser compatibility**: No filesystem access required
- **Portability**: Works in any JavaScript environment
- **Self-contained**: All headers provided as strings
- **Standard C++ syntax**: Use `#include <header>` normally
```

**Done When**: README updated with VFS documentation

---

### Task 12: Create Summary

**Type**: Documentation
**Action**: Create Phase 27-03 summary
**Priority**: MEDIUM

**File to Create**: `/Users/alexanderfedin/Projects/hapyy/hupyy-cpp-to-c/website/.planning/phases/27-wasm-vfs-integration/27-03-SUMMARY.md`

**Content**:
```markdown
# Phase 27-03 Summary: WASM Bindings for VFS

**Status**: ‚úÖ COMPLETED
**Date**: 2025-12-23

## What Was Implemented

Updated Emscripten bindings to expose virtualFiles and includePaths to JavaScript, enabling browser-based transpilation with in-memory headers.

## Changes Made

### WASM Structures Added
- VirtualFile struct (path + content)
- Updated TranspileOptions with virtualFiles and includePaths fields

### Bindings Updated
- Added Embind bindings for VirtualFile
- Updated TranspileOptions bindings with new fields
- Registered VirtualFileVector and StringVector

### Both Builds Updated
- bindings/full.cpp ‚úÖ
- bindings/minimal.cpp ‚úÖ

### TypeScript Definitions
- Updated types.ts with VirtualFile interface
- Added fields to TranspileOptions interface

## Code Statistics
- **Lines added**: ~35 lines across both bindings
- **NO placeholders**: ‚úÖ
- **NO TODO markers**: ‚úÖ

## Test Results
- Full build: ‚úÖ SUCCESS
- Minimal build: ‚úÖ SUCCESS
- Manual VFS test: ‚úÖ PASSED

## Files Modified
- wasm/bindings/full.cpp
- wasm/bindings/minimal.cpp
- wasm/glue/src/types.ts
- wasm/README.md

## Files Created
- wasm/test/test-vfs.js

## Next Steps
Phase 27-04: Standard Library Headers Bundle
```

**Done When**: Summary created

---

### Task 13: Commit Changes

**Type**: Git
**Action**: Commit WASM bindings update
**Priority**: HIGH

**Git Workflow**:
```bash
cd /Users/alexanderfedin/Projects/hapyy/hupyy-cpp-to-c

git checkout develop

git add wasm/bindings/full.cpp
git add wasm/bindings/minimal.cpp
git add wasm/glue/src/types.ts
git add wasm/test/test-vfs.js
git add wasm/README.md
git add wasm/glue/dist/  # Updated WASM artifacts
git add website/.planning/phases/27-wasm-vfs-integration/27-03-SUMMARY.md

git commit -m "$(cat <<'EOF'
feat(27-03): Add WASM bindings for VFS and include paths

FEATURE: JavaScript/TypeScript can now pass virtual files to WASM transpiler

What Was Implemented:
- Added VirtualFile struct to WASM bindings
- Updated TranspileOptions with virtualFiles and includePaths
- Added Embind bindings for new types
- Registered VirtualFileVector and StringVector
- Updated both full and minimal builds

API Changes (JavaScript):
interface VirtualFile { path: string; content: string; }
interface TranspileOptions {
    virtualFiles?: VirtualFile[];
    includePaths?: string[];
}

Implementation:
- VirtualFile struct maps to library's pair<string, string>
- WASMTranspiler::transpile maps WASM options to library options
- ~35 lines of code across both bindings

Testing:
- Full build: ‚úÖ SUCCESS
- Minimal build: ‚úÖ SUCCESS
- Manual VFS test: ‚úÖ PASSED
- Virtual file resolution works from JavaScript

Code Quality:
- NO placeholders ‚úÖ
- NO TODO markers ‚úÖ
- Consistent with existing binding patterns
- Full TypeScript definitions

Files Modified:
- wasm/bindings/full.cpp (+20 lines)
- wasm/bindings/minimal.cpp (+20 lines)
- wasm/glue/src/types.ts (+8 lines)
- wasm/README.md (+30 lines)

Files Created:
- wasm/test/test-vfs.js (manual test)
- website/.planning/phases/27-wasm-vfs-integration/27-03-SUMMARY.md

Why This Matters:
- Connects C++ VFS (27-01, 27-02) to JavaScript
- Enables browser-based transpilation
- Foundation for Phase 27-04 (stdlib headers)
- Critical for WASM playground integration

Next Phase: 27-04 (Standard Library Headers)

Phase: 27-03
Type: WASM Bindings
Status: COMPLETE ‚úÖ

ü§ñ Generated with [Claude Code](https://claude.com/claude-code)

Co-Authored-By: Claude Sonnet 4.5 <noreply@anthropic.com>
EOF
)"

git push origin develop
```

**Done When**: Changes committed and pushed

---

## Success Criteria

### ‚úÖ Code Quality
- [ ] VirtualFile struct added
- [ ] TranspileOptions updated with VFS fields
- [ ] Mapping logic implemented
- [ ] Embind bindings complete
- [ ] NO placeholders anywhere
- [ ] NO TODO markers

### ‚úÖ Functionality
- [ ] Full build succeeds
- [ ] Minimal build succeeds
- [ ] JavaScript can create VirtualFile objects
- [ ] JavaScript can pass virtualFiles array
- [ ] JavaScript can pass includePaths array
- [ ] Virtual files resolve correctly

### ‚úÖ Testing
- [ ] Manual VFS test passes
- [ ] WASM loads successfully
- [ ] Virtual file resolution works
- [ ] Include paths work

### ‚úÖ Documentation
- [ ] TypeScript definitions updated
- [ ] README documentation added
- [ ] Phase summary created
- [ ] Usage examples provided

### ‚úÖ Git
- [ ] All changes committed
- [ ] WASM artifacts included
- [ ] Pushed to origin/develop

---

## Verification Commands

```bash
# 1. Build full WASM
cd /Users/alexanderfedin/Projects/hapyy/hupyy-cpp-to-c/wasm
./scripts/build-full.sh

# Expected: Build SUCCESS

# 2. Build minimal WASM
./scripts/build-minimal.sh

# Expected: Build SUCCESS

# 3. Run manual VFS test
node test/test-vfs.js

# Expected: ‚úÖ Test PASSED

# 4. Check TypeScript
cd glue
npm run build

# Expected: No TS errors

# 5. Verify git
cd /Users/alexanderfedin/Projects/hapyy/hupyy-cpp-to-c
git log -1 --oneline
git status
```

---

## Output

After this phase:

1. **JavaScript VFS Access**: Can pass virtual files from JavaScript to C++
2. **Type Safety**: Full TypeScript definitions
3. **Both Builds**: Full and minimal support VFS
4. **Tested**: Manual test verifies it works
5. **Ready for Stdlib**: Can now bundle headers (Phase 27-04)

**Scope**: ~35 lines of binding code
**Complexity**: Low (follows Embind patterns)
**Risk**: Low (additive changes only)
**Time Estimate**: 2 hours

---

**Status**: üìã Plan Ready for Execution
**Dependencies**: Phase 27-01 (VFS) ‚úÖ, Phase 27-02 (Include Paths) ‚úÖ
**Blocks**: Phase 27-04 (needs WASM bindings for stdlib)
