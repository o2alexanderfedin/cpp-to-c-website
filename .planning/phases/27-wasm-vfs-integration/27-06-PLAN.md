# Phase 27, Plan 27-06: Update WasmTranspilerAdapter for WASM

**Phase**: 27 - WASM VFS Integration
**Plan**: 27-06 - Connect Playground to WASM Transpiler
**Type**: Implementation (Integration)
**Created**: 2025-12-23

---

## Objective

Update WasmTranspilerAdapter to use actual WASM module (or keep HTTP backend based on Phase 27-05 decision).

**Success**: Playground transpiles C++ code using WASM/backend with VFS support.

---

## Context

### Current State
- Current: WasmTranspilerAdapter uses HTTP API
- File: `website/src/adapters/WasmTranspilerAdapter.ts`
- VFS ready in WASM bindings (27-03)
- Stdlib headers bundled (27-04)

### Decision from Phase 27-05
This plan has TWO paths depending on 27-05 outcome.

---

## Path A: If WASM Build Succeeded

### Task 1: Update WasmTranspilerAdapter to Load WASM

**File**: `website/src/adapters/WasmTranspilerAdapter.ts`

**Replace HTTP logic with**:
```typescript
import createCppToC from '@/wasm/glue/dist/full/cpptoc.js';
import { loadStdLibHeaders, getStdLibIncludePaths } from '@/wasm/glue/dist/stdlib-loader';

export class WasmTranspilerAdapter implements ITranspiler {
    private transpiler: any = null;
    private Module: any = null;
    private initialized = false;

    async initialize() {
        if (this.initialized) return;

        // Load WASM module
        this.Module = await createCppToC();
        this.transpiler = new this.Module.Transpiler();

        // Pre-load stdlib headers
        const stdlibHeaders = loadStdLibHeaders();
        const includePaths = getStdLibIncludePaths();

        this.initialized = true;
    }

    async transpile(source: string, options?: TranspileOptions): Promise<TranspileResult> {
        await this.initialize();

        // Create WASM options
        const wasmOptions = new this.Module.TranspileOptions();

        // Add stdlib headers
        const virtualFiles = new this.Module.VirtualFileVector();
        for (const header of loadStdLibHeaders()) {
            const vf = new this.Module.VirtualFile();
            vf.path = header.path;
            vf.content = header.content;
            virtualFiles.push_back(vf);
        }

        // Add custom virtual files (if any)
        // ... from options

        wasmOptions.virtualFiles = virtualFiles;

        // Add include paths
        const includePaths = new this.Module.StringVector();
        for (const path of getStdLibIncludePaths()) {
            includePaths.push_back(path);
        }
        wasmOptions.includePaths = includePaths;

        // Map other options
        if (options?.target) wasmOptions.target = options.target;
        // ...

        // Transpile
        const result = this.transpiler.transpile(source, wasmOptions);

        return {
            success: result.success,
            cCode: result.c,
            diagnostics: this.mapDiagnostics(result.diagnostics)
        };
    }
}
```

**Done When**: Adapter loads and uses WASM

---

## Path B: If HTTP Backend Chosen

### Task 1: Keep HTTP Backend, Add VFS Support

**File**: `website/src/adapters/WasmTranspilerAdapter.ts`

**Update to send stdlib headers**:
```typescript
async transpile(source: string, options?: TranspileOptions): Promise<TranspileResult> {
    // Load stdlib headers
    const stdlibHeaders = loadStdLibHeaders();
    const includePaths = getStdLibIncludePaths();

    // Prepare request with VFS
    const request: TranspileRequest = {
        source,
        options: {
            ...options,
            virtualFiles: stdlibHeaders,
            includePaths
        }
    };

    // Send to backend API
    const response = await fetch(`${this.apiUrl}/api/transpile`, {
        method: 'POST',
        headers: { 'Content-Type': 'application/json' },
        body: JSON.stringify(request)
    });

    return response.json();
}
```

**Backend**: Already supports virtualFiles from Phase 27 (if implemented)

**Done When**: HTTP backend sends VFS data

---

## Common Tasks (Both Paths)

### Task 2: Update Worker Integration

**File**: `website/src/workers/transpiler.worker.ts`

Ensure worker uses updated adapter.

**Verification**:
- Worker initializes adapter
- Transpilation works off-main-thread
- Progress reporting works

**Done When**: Worker integration complete

---

### Task 3: Test with Playground

**Manual Test**:
1. Open playground: `http://localhost:4321/playground`
2. Enter C++ code with `#include <vector>`
3. Click "Transpile"
4. Verify:
   - Transpilation succeeds
   - C code generated
   - NO "file not found" errors
   - NO placeholder text

**Done When**: Playground works end-to-end

---

### Task 4: Performance Testing

**Metrics to measure**:
- WASM load time (if WASM)
- Transpilation time
- Memory usage
- Comparison with HTTP backend (if applicable)

**Document in summary**

**Done When**: Performance acceptable

---

### Task 5: Update Documentation

**File**: `website/README.md`

Document:
- How transpiler is integrated
- WASM vs HTTP architecture
- Performance characteristics
- How to use VFS features

**Done When**: README updated

---

### Task 6: Create Summary

**File**: `27-06-SUMMARY.md`

Document:
- Path taken (WASM or HTTP)
- Changes made
- Test results
- Performance metrics
- Known limitations

**Done When**: Summary complete

---

### Task 7: Commit

```bash
git add website/src/adapters/WasmTranspilerAdapter.ts
git add website/src/workers/transpiler.worker.ts
git add website/README.md
git add website/.planning/phases/27-wasm-vfs-integration/27-06-SUMMARY.md

git commit -m "feat(27-06): [Integrate WASM transpiler | Update HTTP backend with VFS]"
git push origin develop
```

---

## Success Criteria

### WASM Path
- [ ] WASM module loads
- [ ] Stdlib headers pre-loaded
- [ ] Transpilation works in browser
- [ ] Performance acceptable
- [ ] NO network requests

### HTTP Path
- [ ] Backend receives VFS data
- [ ] Stdlib headers sent to backend
- [ ] Transpilation works
- [ ] Performance acceptable
- [ ] Network efficient

### Common
- [ ] Playground works end-to-end
- [ ] NO placeholders in output
- [ ] Error handling robust
- [ ] Documentation complete

---

## Verification

```bash
# 1. Start dev server
cd website
npm run dev

# 2. Test in browser
open http://localhost:4321/playground

# 3. Test C++ with stdlib
# Enter: #include <vector>
#        std::vector<int> v;

# Expected: Transpilation succeeds

# 4. Check console
# Expected: NO errors, NO "file not found"
```

---

**Status**: ðŸ“‹ Plan Ready
**Dependencies**: 27-03 âœ…, 27-04 âœ…, 27-05 (decision)
**Time Estimate**: 2-3 hours
