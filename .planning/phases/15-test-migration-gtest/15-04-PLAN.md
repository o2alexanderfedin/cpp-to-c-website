# Phase 15-04: Unified Test Execution & Code Coverage

**Sub-Phase**: 15-04 of 4
**Target**: Create unified test runner and enable comprehensive code coverage reporting
**Effort**: 8-12 hours
**Risk**: LOW

## Objective

Implement unified test execution infrastructure and comprehensive code coverage reporting for all 988 tests. This provides a single command to run all tests and generates detailed coverage reports to guide future testing efforts.

**Why this is final phase**:
- All tests migrated to GTest (phases 15-01 through 15-03 complete)
- Build system ready for integration
- Coverage infrastructure already present in CMakeLists.txt (ENABLE_COVERAGE option)

## Context

**Current State** (after phases 15-01, 15-02, 15-03):
- ✅ All 988 tests migrated to Google Test
- ✅ CTest integration complete
- ✅ Test discovery working (`gtest_discover_tests()`)
- ✅ Coverage flags already configured in CMakeLists.txt

**CMakeLists.txt Coverage Infrastructure** (already exists):
```cmake
option(ENABLE_COVERAGE "Enable code coverage reporting" OFF)

if(ENABLE_COVERAGE)
    # Coverage flags
    set(COVERAGE_FLAGS "--coverage -fprofile-arcs -ftest-coverage")
    set(CMAKE_C_FLAGS "${CMAKE_C_FLAGS} ${COVERAGE_FLAGS}")
    set(CMAKE_CXX_FLAGS "${CMAKE_CXX_FLAGS} ${COVERAGE_FLAGS}")
    set(CMAKE_EXE_LINKER_FLAGS "${CMAKE_EXE_LINKER_FLAGS} --coverage")

    # Custom target for coverage report
    add_custom_target(coverage ...)
endif()
```

## Tasks

### Task 1: Create Unified Test Runner Script
**Type**: Script development
**Files**: scripts/run-all-tests.sh (new)
**Action**:

1. Create comprehensive test runner:
```bash
#!/bin/bash
# run-all-tests.sh - Unified test execution for C++ to C transpiler
set -e

# Colors for output
RED='\033[0;31m'
GREEN='\033[0;32m'
YELLOW='\033[1;33m'
NC='\033[0m' # No Color

# Configuration
BUILD_DIR="${BUILD_DIR:-build}"
PARALLEL_JOBS="${PARALLEL_JOBS:-$(nproc 2>/dev/null || sysctl -n hw.ncpu 2>/dev/null || echo 4)}"
VERBOSE="${VERBOSE:-0}"
COVERAGE="${COVERAGE:-0}"

echo "========================================"
echo "C++ to C Transpiler - Test Suite Runner"
echo "========================================"
echo "Build directory: $BUILD_DIR"
echo "Parallel jobs: $PARALLEL_JOBS"
echo

# Build tests if needed
if [ ! -d "$BUILD_DIR" ] || [ "$1" == "--rebuild" ]; then
    echo "${YELLOW}Building tests...${NC}"
    mkdir -p "$BUILD_DIR"
    cd "$BUILD_DIR"

    if [ "$COVERAGE" == "1" ]; then
        cmake -DENABLE_COVERAGE=ON ..
    else
        cmake ..
    fi

    make -j"$PARALLEL_JOBS"
    cd ..
fi

# Run tests
echo "${YELLOW}Running tests...${NC}"
cd "$BUILD_DIR"

if [ "$VERBOSE" == "1" ]; then
    ctest --output-on-failure --parallel "$PARALLEL_JOBS"
else
    ctest --parallel "$PARALLEL_JOBS"
fi

TEST_RESULT=$?

# Summary
echo
echo "========================================"
if [ $TEST_RESULT -eq 0 ]; then
    echo "${GREEN}✓ All tests passed!${NC}"
else
    echo "${RED}✗ Some tests failed${NC}"
fi
echo "========================================"

# Coverage report if enabled
if [ "$COVERAGE" == "1" ]; then
    echo
    echo "${YELLOW}Generating coverage report...${NC}"
    make coverage
    echo "${GREEN}Coverage report generated in $BUILD_DIR/coverage/index.html${NC}"
fi

exit $TEST_RESULT
```

2. Make executable:
```bash
chmod +x scripts/run-all-tests.sh
```

3. Test runner:
```bash
./scripts/run-all-tests.sh
```

**Verify**:
- Script runs all 988 tests
- Parallel execution works
- Exit code reflects test results

**Done**: ☐

### Task 2: Create Coverage Generation Script
**Type**: Script development
**Files**: scripts/generate-coverage.sh (new)
**Action**:

1. Create dedicated coverage script:
```bash
#!/bin/bash
# generate-coverage.sh - Code coverage report generation
set -e

BUILD_DIR="${BUILD_DIR:-build}"

echo "========================================"
echo "Code Coverage Report Generation"
echo "========================================"

# Check for required tools
if ! command -v lcov &> /dev/null; then
    echo "ERROR: lcov not found. Install with: brew install lcov"
    exit 1
fi

if ! command -v genhtml &> /dev/null; then
    echo "ERROR: genhtml not found. Install with: brew install lcov"
    exit 1
fi

# Rebuild with coverage enabled
echo "Rebuilding with coverage enabled..."
mkdir -p "$BUILD_DIR"
cd "$BUILD_DIR"
cmake -DENABLE_COVERAGE=ON ..
make -j$(nproc 2>/dev/null || sysctl -n hw.ncpu 2>/dev/null || echo 4)

# Initialize coverage data
echo "Initializing coverage data..."
lcov --directory . --zerocounters

# Run all tests
echo "Running tests..."
ctest --parallel $(nproc 2>/dev/null || sysctl -n hw.ncpu 2>/dev/null || echo 4)

# Capture coverage data
echo "Capturing coverage data..."
lcov --directory . --capture --output-file coverage.info

# Remove system and test files from coverage
echo "Filtering coverage data..."
lcov --remove coverage.info \
    '/usr/*' \
    '*/tests/*' \
    '*/build/*' \
    '*/examples/*' \
    '*/benchmarks/*' \
    --output-file coverage.info.cleaned

# Generate HTML report
echo "Generating HTML report..."
genhtml coverage.info.cleaned \
    --output-directory coverage \
    --demangle-cpp \
    --title "C++ to C Transpiler Coverage" \
    --legend \
    --show-details

# Summary
echo
echo "========================================"
echo "Coverage report generated!"
echo "========================================"
echo "HTML report: $BUILD_DIR/coverage/index.html"
echo
echo "Open with: open $BUILD_DIR/coverage/index.html"
echo

# Extract summary statistics
lcov --summary coverage.info.cleaned
```

2. Make executable and test:
```bash
chmod +x scripts/generate-coverage.sh
./scripts/generate-coverage.sh
```

**Verify**:
- Coverage report generates successfully
- HTML output viewable in browser
- Summary statistics displayed

**Done**: ☐

### Task 3: Enhance CMake Test Targets
**Type**: Build system enhancement
**Files**: CMakeLists.txt
**Action**:

1. Add convenience test targets to main CMakeLists.txt:
```cmake
# Test target aliases for convenience
add_custom_target(test-all
    COMMAND ${CMAKE_CTEST_COMMAND} --output-on-failure
    COMMENT "Running all tests"
    USES_TERMINAL
)

add_custom_target(test-core
    COMMAND ${CMAKE_CTEST_COMMAND} -L "core" --output-on-failure
    COMMENT "Running core unit tests only"
    USES_TERMINAL
)

add_custom_target(test-integration
    COMMAND ${CMAKE_CTEST_COMMAND} -L "integration" --output-on-failure
    COMMENT "Running integration tests only"
    USES_TERMINAL
)

add_custom_target(test-real-world
    COMMAND ${CMAKE_CTEST_COMMAND} -L "real-world" --output-on-failure
    COMMENT "Running real-world tests only"
    USES_TERMINAL
)

add_custom_target(test-parallel
    COMMAND ${CMAKE_CTEST_COMMAND} --parallel $(nproc || echo 4)
    COMMENT "Running tests in parallel"
    USES_TERMINAL
)

add_custom_target(test-verbose
    COMMAND ${CMAKE_CTEST_COMMAND} --output-on-failure --verbose
    COMMENT "Running tests with verbose output"
    USES_TERMINAL
)
```

2. Verify targets work:
```bash
cd build
make test-all
make test-core
make test-integration
```

**Verify**:
- All custom targets functional
- Labels correctly filter tests

**Done**: ☐

### Task 4: Update Coverage Target in CMakeLists.txt
**Type**: Build system enhancement
**Files**: CMakeLists.txt
**Action**:

1. Enhance existing coverage target to run tests automatically:
```cmake
if(LCOV_PATH AND GENHTML_PATH)
    add_custom_target(coverage
        COMMAND ${CMAKE_COMMAND} -E echo "Generating coverage report..."

        # Initialize coverage data
        COMMAND ${LCOV_PATH} --directory . --zerocounters

        # Run ALL tests (this is the key addition)
        COMMAND ${CMAKE_CTEST_COMMAND} --parallel ${PARALLEL_JOBS}

        # Capture coverage data
        COMMAND ${LCOV_PATH} --directory . --capture --output-file coverage.info

        # Remove system headers and test files from coverage
        COMMAND ${LCOV_PATH} --remove coverage.info
            '/usr/*'
            '*/tests/*'
            '*/build/*'
            '*/examples/*'
            '*/benchmarks/*'
            --output-file coverage.info.cleaned

        # Generate HTML report
        COMMAND ${GENHTML_PATH} coverage.info.cleaned
            --output-directory coverage
            --demangle-cpp
            --title "C++ to C Transpiler Coverage"
            --legend
            --show-details

        # Print summary
        COMMAND ${LCOV_PATH} --summary coverage.info.cleaned

        COMMAND ${CMAKE_COMMAND} -E echo "Coverage report: ${CMAKE_BINARY_DIR}/coverage/index.html"

        WORKING_DIRECTORY ${CMAKE_BINARY_DIR}
        COMMENT "Generating code coverage report with HTML output"
        USES_TERMINAL
    )
endif()
```

2. Test coverage target:
```bash
cd build
cmake -DENABLE_COVERAGE=ON ..
make coverage
```

**Verify**:
- Coverage target runs all tests
- HTML report generated
- Summary displayed

**Done**: ☐

### Task 5: Create Quick-Start Documentation
**Type**: Documentation
**Files**: docs/testing.md (new)
**Action**:

1. Create comprehensive testing guide:
```markdown
# Testing Guide - C++ to C Transpiler

## Quick Start

### Run All Tests
```bash
# Option 1: Using script (recommended)
./scripts/run-all-tests.sh

# Option 2: Using CMake
cd build && make test-all

# Option 3: Using CTest directly
cd build && ctest
```

### Run Specific Test Categories
```bash
# Core unit tests only
make test-core

# Integration tests only
make test-integration

# Real-world tests only
make test-real-world
```

### Run Tests in Parallel
```bash
# Automatic parallel execution
./scripts/run-all-tests.sh

# Or using CMake
make test-parallel

# Or using CTest with specific job count
ctest --parallel 8
```

### Generate Code Coverage
```bash
# Option 1: Using dedicated script
./scripts/generate-coverage.sh

# Option 2: Using environment variable
COVERAGE=1 ./scripts/run-all-tests.sh

# Option 3: Using CMake target
cd build
cmake -DENABLE_COVERAGE=ON ..
make coverage

# View coverage report
open build/coverage/index.html
```

## Test Organization

### Test Categories
- **Core Unit Tests** (720 tests): Tests for core transpiler features
- **Real-World Integration** (252 tests): End-to-end integration tests
- **Example Tests** (16 tests): Example/demonstration tests

### Test Labels
Tests are labeled for easy filtering:
- `core` - Core transpiler functionality
- `unit` - Unit tests
- `integration` - Integration tests
- `real-world` - Real-world scenario tests

Filter by label:
```bash
ctest -L "core"
ctest -L "integration"
ctest -L "real-world"
```

## Writing Tests

### Test Structure (Google Test)
```cpp
#include <gtest/gtest.h>

TEST(TestSuiteName, TestName) {
    // Arrange
    auto input = createInput();

    // Act
    auto result = performOperation(input);

    // Assert
    ASSERT_NE(result, nullptr);
    EXPECT_EQ(result->value, 42);
}
```

### Test Fixtures
```cpp
class MyTestFixture : public ::testing::Test {
protected:
    void SetUp() override {
        // Common setup
    }

    void TearDown() override {
        // Cleanup
    }

    // Helper methods
};

TEST_F(MyTestFixture, TestWithFixture) {
    // Uses fixture setup
}
```

## CI/CD Integration

Tests run automatically on:
- Every push to `develop` and `main`
- Every pull request
- Nightly builds with coverage reports

### GitHub Actions
Test results are published as GitHub Actions artifacts:
- Test XML reports: `test-results.xml`
- Coverage reports: `coverage-report.html`

## Troubleshooting

### Build Failures
```bash
# Clean rebuild
rm -rf build && mkdir build && cd build
cmake .. && make -j8
```

### Test Failures
```bash
# Run with verbose output
ctest --output-on-failure --verbose

# Run specific test
./build/ACSLStatementAnnotatorTest
```

### Coverage Issues
```bash
# Ensure lcov is installed
brew install lcov

# Rebuild with coverage
cd build
cmake -DENABLE_COVERAGE=ON ..
make clean && make -j8
```

## Performance

**Expected Test Execution Time**:
- All 988 tests (parallel): ~5-10 minutes
- All 988 tests (sequential): ~15-20 minutes
- Core tests only: ~3-5 minutes
- Integration tests only: ~2-3 minutes

**Coverage Generation Time**:
- Full coverage report: ~10-15 minutes
```

**Verify**:
- Documentation accurate
- Commands tested and working
- Clear for developers

**Done**: ☐

### Task 6: Update README with Test Instructions
**Type**: Documentation
**Files**: README.md
**Action**:

1. Add testing section to README:
```markdown
## Testing

The project has **988 comprehensive tests** covering all transpiler features.

### Quick Start

```bash
# Run all tests
./scripts/run-all-tests.sh

# Generate code coverage
./scripts/generate-coverage.sh
```

### Test Categories
- **Core Unit Tests**: 720 tests for transpiler features
- **Real-World Integration**: 252 end-to-end tests
- **Examples**: 16 demonstration tests

See [docs/testing.md](docs/testing.md) for comprehensive testing guide.
```

**Verify**:
- README updated
- Links functional

**Done**: ☐

### Task 7: Create CI/CD Workflow Integration
**Type**: CI/CD configuration
**Files**: .github/workflows/test.yml (update existing or create new)
**Action**:

1. Create/update GitHub Actions workflow:
```yaml
name: Tests

on:
  push:
    branches: [main, develop]
  pull_request:
    branches: [main, develop]

jobs:
  test:
    name: Run Tests
    runs-on: ubuntu-latest

    steps:
      - uses: actions/checkout@v3

      - name: Install dependencies
        run: |
          sudo apt-get update
          sudo apt-get install -y cmake g++ llvm-14 clang-14 lcov

      - name: Build and test
        run: |
          mkdir build && cd build
          cmake ..
          make -j4
          ctest --output-on-failure --parallel 4

      - name: Generate coverage
        run: |
          cd build
          cmake -DENABLE_COVERAGE=ON ..
          make coverage

      - name: Upload coverage report
        uses: actions/upload-artifact@v3
        with:
          name: coverage-report
          path: build/coverage/

      - name: Upload test results
        if: always()
        uses: actions/upload-artifact@v3
        with:
          name: test-results
          path: build/Testing/
```

2. Verify workflow:
```bash
# Push to trigger workflow
git add .github/workflows/test.yml
git commit -m "ci: add comprehensive test workflow"
git push
```

**Verify**:
- Workflow triggers on push/PR
- Tests run successfully in CI
- Coverage report uploaded

**Done**: ☐

### Task 8: Final Validation and Benchmarking
**Type**: Verification
**Action**:

1. **Comprehensive test run**:
```bash
# Clean build and full test run
rm -rf build
./scripts/run-all-tests.sh --rebuild
```

2. **Measure test execution time**:
```bash
# Sequential
time (cd build && ctest --no-parallel)

# Parallel
time (cd build && ctest --parallel 8)
```

3. **Generate and review coverage**:
```bash
./scripts/generate-coverage.sh
open build/coverage/index.html
```

4. **Document metrics**:
   - Total test count: 988
   - Pass rate: 100% (988/988)
   - Execution time (parallel): [X] minutes
   - Execution time (sequential): [Y] minutes
   - Code coverage: [Z]%
   - Lines of code covered: [N] / [M]

5. **Memory leak verification**:
```bash
# Run subset of tests with valgrind
cd build
for test in ACSLStatementAnnotatorTest \
            RuntimeModeInlineTest \
            LambdaTranslatorTest \
            JsonParserTest; do
    echo "Checking $test..."
    valgrind --leak-check=full --error-exitcode=1 ./$test
done
```

**Verify**:
- All 988 tests passing
- No memory leaks
- Coverage report complete
- Metrics documented

**Done**: ☐

## Checkpoints

**Checkpoint 1** (after Tasks 1-2): Scripts functional
- Test runner works
- Coverage generation works

**Checkpoint 2** (after Tasks 3-4): CMake targets ready
- Convenience targets available
- Coverage integrated

**Checkpoint 3** (after Tasks 5-7): Documentation complete
- Testing guide written
- README updated
- CI/CD configured

## Verification

Before declaring 15-04 complete, verify ALL of these:
- ✓ Unified test runner script (`run-all-tests.sh`) works
- ✓ Coverage generation script (`generate-coverage.sh`) works
- ✓ CMake test targets functional (`make test-all`, etc.)
- ✓ Coverage target updated and working (`make coverage`)
- ✓ Documentation complete (testing.md, README.md)
- ✓ CI/CD workflow configured and tested
- ✓ All 988 tests passing via all execution methods
- ✓ Coverage report generates with >70% coverage
- ✓ No memory leaks detected

## Success Criteria

- Single command runs all tests: `./scripts/run-all-tests.sh`
- Single command generates coverage: `./scripts/generate-coverage.sh`
- CMake targets provide convenient shortcuts
- Documentation guides developers clearly
- CI/CD automatically runs tests on every push
- Code coverage measured and reported

## Output

Generate summary at: `.planning/phases/15-test-migration-gtest/15-04-SUMMARY.md`

Also generate final Phase 15 summary at: `.planning/phases/15-test-migration-gtest/15-FINAL-SUMMARY.md`

---

**Prepared by**: Claude Sonnet 4.5
**Date**: 2025-12-20
**Execution**: `/run-plan .planning/phases/15-test-migration-gtest/15-04-PLAN.md`
