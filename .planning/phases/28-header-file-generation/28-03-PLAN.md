# Phase 28, Plan 28-03: Integrate Header Generation into WASM and Web Page

**Phase**: 28 - Header File Generation
**Plan**: 28-03 - Ensure All Built into WASM and Working in Web Page
**Type**: Integration & Verification
**Created**: 2025-12-23

---

## Objective

Ensure Phase 28 header/implementation separation with forward declarations is:
1. Built into native code ‚úÖ (Already working)
2. Built into WASM with proper bindings
3. Working in the web page playground
4. Fully tested end-to-end

**Success**: Users can transpile C++ code in the web playground and receive both `.h` and `.c` files with proper forward declarations.

**User Requirement**: "Ensure all built into both native code and wasm. Ensure that works in the web page."

---

## Context

### Current State After Phase 28-01 and 28-02

**Native Build** ‚úÖ:
- `TranspilerAPI.cpp` uses `HeaderSeparator` and `IncludeGuardGenerator`
- `CodeGenerator.cpp` has `IncludeTagDefinition = false` fix
- `TranspileResult` has `.h` field (populated)
- 18/18 tests passing
- All commits pushed to develop

**WASM Build** ‚ùå:
- WASM bindings (`full.cpp`, `minimal.cpp`) include `TranspilerAPI.h`
- **Missing**: `.h` field not exposed in WASM bindings
- **Missing**: TypeScript types not updated
- **Not tested**: WASM build may be broken

**Web Page** ‚ùå:
- `WasmTranspilerAdapter` doesn't handle `.h` field
- UI doesn't display header files
- No tests for header generation in web context

---

## Tasks

### Task 1: Update WASM Bindings to Include `.h` Field

**Files**:
- `/Users/alexanderfedin/Projects/hapyy/hupyy-cpp-to-c/wasm/bindings/full.cpp`
- `/Users/alexanderfedin/Projects/hapyy/hupyy-cpp-to-c/wasm/bindings/minimal.cpp`

**Changes Needed**:

#### 1.1: Update WASM TranspileResult Struct

**File**: `wasm/bindings/full.cpp` (lines 39-44)

**Current**:
```cpp
struct TranspileResult {
    bool success = false;
    std::string c;
    std::string acsl;
    std::vector<Diagnostic> diagnostics;
};
```

**New**:
```cpp
struct TranspileResult {
    bool success = false;
    std::string c;
    std::string h;           // ‚Üê ADD THIS
    std::string acsl;
    std::vector<Diagnostic> diagnostics;
};
```

#### 1.2: Update Result Mapping

**File**: `wasm/bindings/full.cpp` (lines 79-82)

**Current**:
```cpp
// Map library result to WASM result
result.success = libResult.success;
result.c = libResult.c;
result.acsl = libResult.acsl;
```

**New**:
```cpp
// Map library result to WASM result
result.success = libResult.success;
result.c = libResult.c;
result.h = libResult.h;   // ‚Üê ADD THIS
result.acsl = libResult.acsl;
```

#### 1.3: Update Embind Bindings

**File**: `wasm/bindings/full.cpp` (lines 139-143)

**Current**:
```cpp
value_object<TranspileResult>("TranspileResult")
    .field("success", &TranspileResult::success)
    .field("c", &TranspileResult::c)
    .field("acsl", &TranspileResult::acsl)
    .field("diagnostics", &TranspileResult::diagnostics);
```

**New**:
```cpp
value_object<TranspileResult>("TranspileResult")
    .field("success", &TranspileResult::success)
    .field("c", &TranspileResult::c)
    .field("h", &TranspileResult::h)     // ‚Üê ADD THIS
    .field("acsl", &TranspileResult::acsl)
    .field("diagnostics", &TranspileResult::diagnostics);
```

#### 1.4: Repeat for `minimal.cpp`

Apply the same 3 changes to `wasm/bindings/minimal.cpp`.

**Done When**: Both WASM bindings updated

---

### Task 2: Rebuild WASM Modules

**Build Commands**:
```bash
cd /Users/alexanderfedin/Projects/hapyy/hupyy-cpp-to-c

# Clean previous build
rm -rf build-wasm-minimal

# Configure for WASM
emcmake cmake -B build-wasm-minimal -S wasm

# Build both targets
emmake cmake --build build-wasm-minimal --target cpptoc-wasm-full
emmake cmake --build build-wasm-minimal --target cpptoc-wasm-minimal
```

**Verification**:
- Check that builds complete without errors
- Verify `.wasm` and `.js` files are copied to `wasm/glue/dist/`
- Check file sizes are reasonable

**Expected Artifacts**:
- `wasm/glue/dist/full/cpptoc.js`
- `wasm/glue/dist/full/cpptoc.wasm`
- `wasm/glue/dist/minimal/cpptoc.js`
- `wasm/glue/dist/minimal/cpptoc.wasm`

**Done When**: WASM modules built successfully

---

### Task 3: Update TypeScript Types

**File**: `website/src/types/transpiler.ts` (or create if missing)

**Type Definitions**:
```typescript
export interface TranspileResult {
  success: boolean;
  c: string;
  h: string;           // ‚Üê ADD THIS
  acsl?: string;
  diagnostics: Diagnostic[];
}

export interface Diagnostic {
  line: number;
  column: number;
  message: string;
  severity: 'error' | 'warning' | 'note';
}

export interface ACSLOptions {
  statements?: boolean;
  typeInvariants?: boolean;
  axiomatics?: boolean;
  ghostCode?: boolean;
  behaviors?: boolean;
  memoryPredicates?: boolean;
}

export interface TranspileOptions {
  acsl?: ACSLOptions;
  target?: string;
  optimize?: boolean;
  monomorphizeTemplates?: boolean;
  enableExceptions?: boolean;
  exceptionModel?: string;
  enableRTTI?: boolean;
}
```

**Done When**: TypeScript types updated

---

### Task 4: Update WasmTranspilerAdapter

**File**: `website/src/adapters/WasmTranspilerAdapter.ts`

**Current Behavior**: Adapter handles `.c` and `.acsl` fields

**New Behavior**: Adapter must also handle `.h` field

**Changes**:

#### 4.1: Import Updated Types
```typescript
import type { TranspileResult, TranspileOptions } from '@/types/transpiler';
```

#### 4.2: Update Result Handling
```typescript
async transpile(source: string, options?: TranspileOptions): Promise<TranspileResult> {
    // ... existing code ...

    const result = await this.wasmTranspiler.transpile(source, wasmOptions);

    return {
        success: result.success,
        c: result.c,
        h: result.h,           // ‚Üê ADD THIS
        acsl: result.acsl,
        diagnostics: result.diagnostics
    };
}
```

**Done When**: Adapter returns `.h` field

---

### Task 5: Update Web UI to Display Header Files

**File**: `website/src/components/Playground.vue` (or similar)

**Current UI**: Shows only C code output

**New UI**: Show both .h and .c outputs in tabs or split view

**Implementation Options**:

#### Option A: Tabbed View
```vue
<template>
  <div class="output-container">
    <div class="tabs">
      <button @click="activeTab = 'h'" :class="{active: activeTab === 'h'}">
        Header (.h)
      </button>
      <button @click="activeTab = 'c'" :class="{active: activeTab === 'c'}">
        Implementation (.c)
      </button>
      <button v-if="result.acsl" @click="activeTab = 'acsl'"
              :class="{active: activeTab === 'acsl'}">
        ACSL
      </button>
    </div>

    <div class="code-output">
      <CodeEditor v-if="activeTab === 'h'" :value="result.h" readonly />
      <CodeEditor v-if="activeTab === 'c'" :value="result.c" readonly />
      <CodeEditor v-if="activeTab === 'acsl'" :value="result.acsl" readonly />
    </div>
  </div>
</template>
```

#### Option B: Split View
```vue
<template>
  <div class="output-container split">
    <div class="pane">
      <h3>Header File (.h)</h3>
      <CodeEditor :value="result.h" readonly />
    </div>

    <div class="pane">
      <h3>Implementation File (.c)</h3>
      <CodeEditor :value="result.c" readonly />
    </div>
  </div>
</template>
```

**Recommendation**: Use **Option A (Tabbed View)** for better space utilization on mobile.

**Done When**: UI displays both .h and .c files

---

### Task 6: Add Download Buttons for Both Files

**File**: Same as Task 5

**Feature**: Users can download both .h and .c files separately

**Implementation**:
```vue
<template>
  <div class="download-buttons">
    <button @click="downloadFile(result.h, 'output.h')">
      Download Header (.h)
    </button>
    <button @click="downloadFile(result.c, 'output.c')">
      Download Implementation (.c)
    </button>
    <button v-if="result.acsl" @click="downloadFile(result.acsl, 'output.acsl')">
      Download ACSL
    </button>
  </div>
</template>

<script setup lang="ts">
function downloadFile(content: string, filename: string) {
  const blob = new Blob([content], { type: 'text/plain' });
  const url = URL.createObjectURL(blob);
  const a = document.createElement('a');
  a.href = url;
  a.download = filename;
  a.click();
  URL.revokeObjectURL(url);
}
</script>
```

**Done When**: Download buttons work for both files

---

### Task 7: Create Web Integration Tests

**File**: `website/tests/integration/header-generation.test.ts`

**Test Cases**:

```typescript
import { describe, it, expect } from 'vitest';
import { WasmTranspilerAdapter } from '@/adapters/WasmTranspilerAdapter';

describe('Header Generation in Web Context', () => {
    const adapter = new WasmTranspilerAdapter();

    beforeAll(async () => {
        await adapter.initialize();
    });

    it('generates both .h and .c files', async () => {
        const cpp = `
            struct Node {
                int data;
                struct Node* next;
            };

            int add(int a, int b) {
                return a + b;
            }
        `;

        const result = await adapter.transpile(cpp);

        expect(result.success).toBe(true);
        expect(result.h).toBeTruthy();
        expect(result.c).toBeTruthy();
    });

    it('header file contains forward declarations', async () => {
        const cpp = `
            struct Node {
                int data;
                struct Node* next;
            };
        `;

        const result = await adapter.transpile(cpp);

        expect(result.h).toContain('struct Node;');
        expect(result.h).toContain('struct Node {');
    });

    it('header file contains include guards', async () => {
        const cpp = 'int foo() { return 42; }';

        const result = await adapter.transpile(cpp);

        expect(result.h).toMatch(/#ifndef.*\n#define/);
        expect(result.h).toContain('#endif');
    });

    it('.c file includes .h file', async () => {
        const cpp = 'int foo() { return 42; }';

        const result = await adapter.transpile(cpp);

        expect(result.c).toContain('#include');
        expect(result.c).toMatch(/#include ".*\.h"/);
    });

    it('handles mutual struct references', async () => {
        const cpp = `
            struct A {
                int value;
                struct B* b_ptr;
            };

            struct B {
                double data;
                struct A* a_ptr;
            };
        `;

        const result = await adapter.transpile(cpp);

        expect(result.h).toContain('struct A;');
        expect(result.h).toContain('struct B;');
    });
});
```

**Run Tests**:
```bash
cd website
npm test -- header-generation.test.ts
```

**Done When**: All tests passing

---

### Task 8: Manual E2E Testing

**Test Plan**:

1. **Start Dev Server**:
   ```bash
   cd website
   npm run dev
   ```

2. **Open Playground**: Navigate to `http://localhost:4321/playground`

3. **Test Case 1: Simple Struct**
   - Input:
     ```cpp
     struct Point {
         int x, y;
     };

     int getX(struct Point p) {
         return p.x;
     }
     ```
   - Expected:
     - Header tab shows: struct definition + function declaration
     - Implementation tab shows: `#include` + function body
     - Download buttons work for both files

4. **Test Case 2: Self-Referencing Struct**
   - Input:
     ```cpp
     struct Node {
         int data;
         struct Node* next;
     };
     ```
   - Expected:
     - Header contains forward declaration: `struct Node;`
     - Header contains full definition
     - No nested struct definitions

5. **Test Case 3: Mutual References**
   - Input:
     ```cpp
     struct A {
         int value;
         struct B* b_ptr;
     };

     struct B {
         double data;
         struct A* a_ptr;
     };
     ```
   - Expected:
     - Both forward declarations present
     - Both full definitions present
     - No inline struct expansions

6. **Test Case 4: Error Handling**
   - Input: Invalid C++ syntax
   - Expected:
     - Error messages displayed
     - No crash
     - Graceful degradation

**Done When**: All manual test cases pass

---

### Task 9: Update Documentation

**File**: `wasm/README.md`

**Add Section**:
```markdown
## Header/Implementation Separation (Phase 28)

The transpiler generates separate .h and .c files:

### Output Structure

**Header File (.h)**:
- Include guards (`#ifndef` / `#define` / `#endif`)
- Forward declarations (for struct pointers)
- Struct/class definitions
- Function declarations (signatures only)

**Implementation File (.c)**:
- `#include "header.h"`
- Function implementations (full bodies)

### WASM API

The `TranspileResult` object now includes:
```javascript
{
  success: boolean,
  c: string,          // Implementation code
  h: string,          // Header code
  acsl: string,       // ACSL annotations (if enabled)
  diagnostics: Diagnostic[]
}
```

### Example Usage

```javascript
import createCppToC from './cpptoc.js';

const Module = await createCppToC();
const transpiler = new Module.Transpiler();

const cpp = `
  struct Node {
      int data;
      struct Node* next;
  };

  int getLength(struct Node* head) {
      int count = 0;
      while (head) {
          count++;
          head = head->next;
      }
      return count;
  }
`;

const result = transpiler.transpile(cpp, new Module.TranspileOptions());

console.log('=== Header File ===');
console.log(result.h);

console.log('=== Implementation File ===');
console.log(result.c);
```

### Output Example

**Header File (result.h)**:
```c
#ifndef INPUT_CPP_H
#define INPUT_CPP_H

// Forward declarations
struct Node;

struct Node {
    int data;
    struct Node *next;
};

int getLength(struct Node *head);

#endif // INPUT_CPP_H
```

**Implementation File (result.c)**:
```c
#include "input.cpp.h"

int getLength(struct Node *head) {
    int count = 0;
    while (head) {
        count++;
        head = head->next;
    }
    return count;
}
```
```

**Done When**: Documentation updated

---

### Task 10: Create Summary Document

**File**: `28-03-SUMMARY.md`

Document:
- What was integrated
- Build process
- Test results
- UI changes
- Known issues (if any)

**Done When**: Summary complete

---

### Task 11: Commit and Push Changes

```bash
cd /Users/alexanderfedin/Projects/hapyy/hupyy-cpp-to-c

# WASM bindings
git add wasm/bindings/full.cpp
git add wasm/bindings/minimal.cpp

# WASM artifacts (if committed)
git add wasm/glue/dist/

# Documentation
git add wasm/README.md
git add website/.planning/phases/28-header-file-generation/28-03-PLAN.md
git add website/.planning/phases/28-header-file-generation/28-03-SUMMARY.md

git commit -m "$(cat <<'EOF'
feat(28-03): Integrate header generation into WASM and web page

WASM Integration Complete: Header/implementation separation now works in browser

What Was Implemented:
- Added .h field to WASM TranspileResult bindings
- Rebuilt WASM modules (full and minimal)
- Updated TypeScript types
- Updated WasmTranspilerAdapter to handle .h field
- Added tabbed UI to display both .h and .c files
- Added download buttons for both files
- Created web integration tests
- Updated documentation

WASM Bindings Changes:
- wasm/bindings/full.cpp: Added .h field to struct and Embind
- wasm/bindings/minimal.cpp: Added .h field to struct and Embind
- Result mapping now includes libResult.h ‚Üí result.h

Web UI Changes:
- Tabbed view: Header (.h) | Implementation (.c) | ACSL
- Download buttons for each file type
- Proper syntax highlighting for both files

Test Coverage:
- 5 web integration tests (all passing)
- Manual E2E testing (6 scenarios)
- Cross-browser verification

Test Results:
- ‚úÖ Header files generated in browser
- ‚úÖ Forward declarations working
- ‚úÖ Include guards present
- ‚úÖ .c includes .h
- ‚úÖ Mutual references handled
- ‚úÖ Download functionality works

Breaking Changes: NONE
- Backward compatible (existing code continues to work)
- .h field is additional, not replacing anything

User Requirement Met:
"Ensure all built into both native code and wasm.
Ensure that works in the web page." ‚úÖ

Quality:
- NO placeholders ‚úÖ
- NO TODO markers ‚úÖ
- All tests passing ‚úÖ
- Full documentation ‚úÖ
- Production-ready ‚úÖ

Phase: 28-03
Type: WASM Integration
Status: COMPLETE ‚úÖ

ü§ñ Generated with [Claude Code](https://claude.com/claude-code)

Co-Authored-By: Claude Sonnet 4.5 <noreply@anthropic.com>
EOF
)"

git push origin develop
```

**Done When**: Changes committed and pushed

---

## Success Criteria

- [ ] WASM bindings include `.h` field
- [ ] WASM modules built successfully
- [ ] TypeScript types updated
- [ ] WasmTranspilerAdapter handles `.h`
- [ ] Web UI displays both .h and .c
- [ ] Download buttons work
- [ ] Web integration tests passing
- [ ] Manual E2E tests passing
- [ ] Documentation updated
- [ ] Changes committed and pushed

---

## Verification Commands

```bash
# 1. Build WASM
cd /Users/alexanderfedin/Projects/hapyy/hupyy-cpp-to-c
emcmake cmake -B build-wasm-minimal -S wasm
emmake cmake --build build-wasm-minimal

# 2. Check artifacts
ls -lh wasm/glue/dist/full/cpptoc.*
ls -lh wasm/glue/dist/minimal/cpptoc.*

# 3. Run web tests
cd website
npm test -- header-generation.test.ts

# 4. Start dev server
npm run dev

# 5. Manual testing
open http://localhost:4321/playground
```

---

## Timeline Estimate

| Task | Time | Description |
|------|------|-------------|
| 1. Update WASM bindings | 30 min | Add .h field to structs |
| 2. Rebuild WASM | 1 hour | emcmake + emmake build |
| 3. Update TypeScript types | 15 min | Type definitions |
| 4. Update adapter | 30 min | Handle .h field |
| 5. Update UI | 2 hours | Tabbed view + styling |
| 6. Download buttons | 30 min | File download logic |
| 7. Integration tests | 1 hour | 5 test cases |
| 8. Manual E2E testing | 1 hour | 6 test scenarios |
| 9. Documentation | 1 hour | README updates |
| 10. Summary | 30 min | Summary document |
| 11. Commit & push | 15 min | Git operations |

**Total**: 8-9 hours

---

## Dependencies

- ‚úÖ Phase 28-01: Header/Implementation Separation
- ‚úÖ Phase 28-02: Forward Declarations Fix
- ‚úÖ Native build working
- ‚è≥ Emscripten installed
- ‚è≥ Node.js & npm installed
- ‚è≥ Website development server working

---

## Risk Assessment

| Risk | Likelihood | Impact | Mitigation |
|------|------------|--------|------------|
| WASM build fails | Medium | High | Check Emscripten version, dependencies |
| Build size too large | Low | Medium | Already optimized with -Oz |
| Browser compatibility | Low | Medium | Test in Chrome, Firefox, Safari |
| UI/UX issues | Medium | Low | User testing, iterate on feedback |

---

**Status**: üìã READY FOR EXECUTION
**Priority**: HIGH (user requirement)
**Type**: Integration & Verification
