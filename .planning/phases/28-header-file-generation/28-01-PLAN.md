# Phase 28, Plan 28-01: Integrate Header/Implementation Separation

**Phase**: 28 - Header File Generation
**Plan**: 28-01 - Enable .h/.c File Separation
**Type**: Implementation (Critical Fix)
**Created**: 2025-12-23

---

## Objective

Integrate existing `HeaderSeparator` and `IncludeGuardGenerator` components into the transpilation pipeline to generate proper .h and .c files.

**Success**: Transpiler generates .h files with declarations and .c files with implementations + `#include "header.h"`.

**User Requirement**: "We **must** emit .h files too. And include these into the .c files for forward declarations."

---

## Context

### Current State
- ‚úÖ `HeaderSeparator` exists - analyzes AST, separates header/impl declarations
- ‚úÖ `IncludeGuardGenerator` exists - generates include guards
- ‚úÖ Two output streams created (`hStream`, `cStream`)
- ‚úÖ `TranspileResult` has `.h` field
- ‚ùå **Not integrated** - all code goes to `.c`, `.h` is empty

### The Problem

From `TranspilerAPI.cpp` lines 120-123:
```cpp
// Generate C code output using CodeGenerator
// For now, output to C stream (we'll separate .h/.c in future iterations)
CodeGenerator CGen(CStream, Context);
CGen.printTranslationUnit(TU);
```

`CodeGenerator` only writes to `cStream`. `HeaderSeparator` is never invoked.

---

## Tasks

### Task 1: Integrate HeaderSeparator into Pipeline

**File**: `/Users/alexanderfedin/Projects/hapyy/hupyy-cpp-to-c/src/TranspilerAPI.cpp`

**Location**: Inside `HandleTranslationUnit` method (around line 108)

**Current Code** (lines 108-128):
```cpp
void HandleTranslationUnit(clang::ASTContext &Context) override {
    // Create CNodeBuilder
    clang::CNodeBuilder Builder(Context);

    // Create and run visitor
    CppToCVisitor Visitor(Context, Builder);
    auto *TU = Context.getTranslationUnitDecl();
    Visitor.TraverseDecl(TU);

    // Process templates
    Visitor.processTemplateInstantiations(TU);

    // Generate C code - CURRENTLY ONLY TO .C
    CodeGenerator CGen(CStream, Context);
    CGen.printTranslationUnit(TU);

    // ... ACSL generation ...
}
```

**New Code** (replace lines 120-123):
```cpp
// Separate declarations into header and implementation
HeaderSeparator separator;
separator.analyzeTranslationUnit(TU);

// Generate include guards for header
IncludeGuardGenerator guardGen(options.usePragmaOnce);
std::string guardName = guardGen.generateGuardName(filename + ".h");

// Write header file (.h)
HStream << guardGen.emitGuardBegin(guardName);
HStream << "\n";

// Forward declarations
const auto& forwardDecls = separator.getForwardDecls();
if (!forwardDecls.empty()) {
    HStream << "// Forward declarations\n";
    for (const auto& fwd : forwardDecls) {
        HStream << "struct " << fwd << ";\n";
    }
    HStream << "\n";
}

// Header declarations (structs, function prototypes)
CodeGenerator HGen(HStream, Context);
for (clang::Decl* decl : separator.getHeaderDecls()) {
    HGen.printDecl(decl, /*declarationOnly=*/true);
}

HStream << guardGen.emitGuardEnd(guardName);

// Write implementation file (.c)
CStream << "#include \"" << filename << ".h\"\n\n";

// Implementation (function bodies)
CodeGenerator CGen(CStream, Context);
for (clang::Decl* decl : separator.getImplDecls()) {
    CGen.printDecl(decl, /*declarationOnly=*/false);
}
```

**Verification**:
- ‚úÖ HeaderSeparator invoked
- ‚úÖ Include guards generated
- ‚úÖ Forward declarations emitted
- ‚úÖ Header gets declarations only
- ‚úÖ Implementation gets full bodies
- ‚úÖ .c includes .h

**Done When**: Integration code complete

---

### Task 2: Update CodeGenerator for Declaration-Only Mode

**File**: `/Users/alexanderfedin/Projects/hapyy/hupyy-cpp-to-c/src/CodeGenerator.cpp`

**Action**: Add `declarationOnly` parameter to `printDecl` method

**Current Signature**:
```cpp
void CodeGenerator::printDecl(Decl *D);
```

**New Signature**:
```cpp
void CodeGenerator::printDecl(Decl *D, bool declarationOnly = false);
```

**Implementation**:
```cpp
void CodeGenerator::printDecl(Decl *D, bool declarationOnly) {
    if (auto *FD = dyn_cast<FunctionDecl>(D)) {
        if (declarationOnly) {
            // Print function signature only (for header)
            printFunctionSignature(FD);
            Out << ";\n";
        } else {
            // Print full function (for implementation)
            printFunction(FD);
        }
    } else if (auto *RD = dyn_cast<RecordDecl>(D)) {
        // Struct definitions always complete (same for header and impl)
        printRecordDecl(RD);
    } else {
        // Other declarations
        D->print(Out);
    }
}
```

**Verification**:
- ‚úÖ Declaration-only mode works
- ‚úÖ Function signatures printed correctly
- ‚úÖ Struct definitions complete
- ‚úÖ Backward compatible (default = false)

**Done When**: CodeGenerator supports declarationOnly mode

---

### Task 3: Add printFunctionSignature Helper

**File**: `/Users/alexanderfedin/Projects/hapyy/hupyy-cpp-to-c/src/CodeGenerator.cpp`

**Action**: Create helper to print function signature without body

**Code to Add**:
```cpp
void CodeGenerator::printFunctionSignature(FunctionDecl *FD) {
    // Return type
    FD->getReturnType().print(Out, Policy);
    Out << " ";

    // Function name
    Out << FD->getNameAsString();

    // Parameters
    Out << "(";
    for (unsigned i = 0; i < FD->getNumParams(); ++i) {
        if (i > 0) Out << ", ";
        ParmVarDecl *Param = FD->getParamDecl(i);
        Param->getType().print(Out, Policy);
        Out << " " << Param->getNameAsString();
    }
    Out << ")";
}
```

**Verification**:
- ‚úÖ Prints correct signature
- ‚úÖ Parameter names included
- ‚úÖ Return type correct
- ‚úÖ No body

**Done When**: Helper function works

---

### Task 4: Update CodeGenerator Header

**File**: `/Users/alexanderfedin/Projects/hapyy/hupyy-cpp-to-c/include/CodeGenerator.h`

**Action**: Add method declarations

**Code to Add**:
```cpp
class CodeGenerator {
public:
    // ... existing methods ...

    /// @brief Print declaration (optionally declaration-only for headers)
    /// @param D Declaration to print
    /// @param declarationOnly If true, print signature only (for .h files)
    void printDecl(Decl *D, bool declarationOnly = false);

private:
    /// @brief Print function signature without body
    /// @param FD Function declaration
    void printFunctionSignature(FunctionDecl *FD);
};
```

**Done When**: Header updated

---

### Task 5: Create Unit Tests

**File**: `/Users/alexanderfedin/Projects/hapyy/hupyy-cpp-to-c/tests/TranspilerAPI_HeaderSeparation_Test.cpp`

**Test Cases**:

#### Test 1: Simple Function - Header/Impl Split
```cpp
TEST(TranspilerAPI_HeaderSeparation, SimpleFunctionSplit) {
    std::string cpp = R"(
        int add(int a, int b) {
            return a + b;
        }
    )";

    auto result = cpptoc::transpile(cpp, "test.cpp");

    EXPECT_TRUE(result.success);

    // Check .h file
    EXPECT_THAT(result.h, HasSubstr("#ifndef TEST_CPP_H"));
    EXPECT_THAT(result.h, HasSubstr("#define TEST_CPP_H"));
    EXPECT_THAT(result.h, HasSubstr("int add(int a, int b);"));
    EXPECT_THAT(result.h, Not(HasSubstr("return a + b")));  // No body in header
    EXPECT_THAT(result.h, HasSubstr("#endif // TEST_CPP_H"));

    // Check .c file
    EXPECT_THAT(result.c, HasSubstr("#include \"test.cpp.h\""));
    EXPECT_THAT(result.c, HasSubstr("int add(int a, int b)"));
    EXPECT_THAT(result.c, HasSubstr("return a + b"));  // Body in implementation
}
```

#### Test 2: Struct Definition in Header
```cpp
TEST(TranspilerAPI_HeaderSeparation, StructInHeader) {
    std::string cpp = R"(
        struct Point {
            int x;
            int y;
        };

        int getX(struct Point p) {
            return p.x;
        }
    )";

    auto result = cpptoc::transpile(cpp, "test.cpp");

    EXPECT_TRUE(result.success);

    // Struct in header
    EXPECT_THAT(result.h, HasSubstr("struct Point {"));
    EXPECT_THAT(result.h, HasSubstr("int x;"));
    EXPECT_THAT(result.h, HasSubstr("int y;"));

    // Function signature in header
    EXPECT_THAT(result.h, HasSubstr("int getX(struct Point p);"));

    // Function body in .c
    EXPECT_THAT(result.c, HasSubstr("return p.x"));
}
```

#### Test 3: Forward Declarations
```cpp
TEST(TranspilerAPI_HeaderSeparation, ForwardDeclarations) {
    std::string cpp = R"(
        struct Node {
            int data;
            struct Node* next;  // Self-reference requires forward decl
        };
    )";

    auto result = cpptoc::transpile(cpp, "test.cpp");

    EXPECT_TRUE(result.success);

    // Forward declaration in header
    EXPECT_THAT(result.h, HasSubstr("struct Node;"));

    // Full definition after forward decl
    EXPECT_THAT(result.h, HasSubstr("struct Node {"));
}
```

#### Test 4: Pragma Once Mode
```cpp
TEST(TranspilerAPI_HeaderSeparation, PragmaOnceMode) {
    cpptoc::TranspileOptions opts;
    opts.usePragmaOnce = true;

    std::string cpp = "int foo() { return 42; }";

    auto result = cpptoc::transpile(cpp, "test.cpp", opts);

    EXPECT_TRUE(result.success);

    // Should use #pragma once instead of guards
    EXPECT_THAT(result.h, HasSubstr("#pragma once"));
    EXPECT_THAT(result.h, Not(HasSubstr("#ifndef")));
    EXPECT_THAT(result.h, Not(HasSubstr("#define")));
}
```

#### Test 5: No Implementation - Header Only
```cpp
TEST(TranspilerAPI_HeaderSeparation, HeaderOnlyDeclarations) {
    std::string cpp = R"(
        int foo();  // Declaration only, no body
        int bar();  // Declaration only
    )";

    auto result = cpptoc::transpile(cpp, "test.cpp");

    EXPECT_TRUE(result.success);

    // Declarations in header
    EXPECT_THAT(result.h, HasSubstr("int foo();"));
    EXPECT_THAT(result.h, HasSubstr("int bar();"));

    // .c file should be minimal (just #include)
    EXPECT_THAT(result.c, HasSubstr("#include \"test.cpp.h\""));
}
```

**Build Integration**:
```cmake
add_executable(TranspilerAPI_HeaderSeparation_Test
    tests/TranspilerAPI_HeaderSeparation_Test.cpp
)
target_link_libraries(TranspilerAPI_HeaderSeparation_Test
    cpptoc_static
    gtest_main
)
add_test(NAME TranspilerAPI_HeaderSeparation
         COMMAND TranspilerAPI_HeaderSeparation_Test)
```

**Verification**:
- ‚úÖ All 5 tests PASS
- ‚úÖ Header guards work
- ‚úÖ Forward declarations work
- ‚úÖ Function split works
- ‚úÖ Pragma once works

**Done When**: All tests passing

---

### Task 6: Update Documentation

**File**: `/Users/alexanderfedin/Projects/hapyy/hupyy-cpp-to-c/README.md`

**Section to Add**:
```markdown
## Header/Implementation Separation

The transpiler generates separate .h and .c files:

### .h File (Header)
- Include guards (`#ifndef` / `#define` / `#endif` or `#pragma once`)
- Forward declarations (for struct pointers)
- Struct/class definitions
- Function declarations (signatures only)

### .c File (Implementation)
- `#include "header.h"`
- Function implementations (full bodies)

### Example

**Input C++:**
```cpp
struct Point {
    int x, y;
};

int distance(Point p1, Point p2) {
    return abs(p1.x - p2.x) + abs(p1.y - p2.y);
}
```

**Output .h:**
```c
#ifndef POINT_H
#define POINT_H

struct Point {
    int x;
    int y;
};

int distance(struct Point p1, struct Point p2);

#endif // POINT_H
```

**Output .c:**
```c
#include "point.h"

int distance(struct Point p1, struct Point p2) {
    return abs(p1.x - p2.x) + abs(p1.y - p2.y);
}
```

### Options

```cpp
cpptoc::TranspileOptions opts;
opts.usePragmaOnce = true;  // Use #pragma once instead of guards
```
```

**Done When**: README updated

---

### Task 7: Create Summary

**File**: `28-01-SUMMARY.md`

Document:
- What was integrated
- Test results
- Code examples
- Breaking changes (if any)

**Done When**: Summary complete

---

### Task 8: Commit Changes

```bash
cd /Users/alexanderfedin/Projects/hapyy/hupyy-cpp-to-c

git checkout develop

git add src/TranspilerAPI.cpp
git add src/CodeGenerator.cpp
git add include/CodeGenerator.h
git add tests/TranspilerAPI_HeaderSeparation_Test.cpp
git add CMakeLists.txt
git add README.md
git add website/.planning/phases/28-header-file-generation/28-01-SUMMARY.md

git commit -m "$(cat <<'EOF'
feat(28-01): Integrate header/implementation file separation

CRITICAL FIX: Generate proper .h and .c files

What Was Implemented:
- Integrated HeaderSeparator into transpilation pipeline
- Modified CodeGenerator to support declaration-only mode
- Added include guard generation to .h files
- Added #include "header.h" to .c files
- Forward declarations for struct pointers

Implementation Details:
- HeaderSeparator analyzes AST and separates declarations
- IncludeGuardGenerator adds guards to .h file
- CodeGenerator has declarationOnly parameter
- .h gets: guards + forward decls + struct defs + function sigs
- .c gets: #include + function implementations

Code Changes:
- TranspilerAPI.cpp: Invoke HeaderSeparator, split output
- CodeGenerator.cpp: Add declarationOnly mode
- CodeGenerator.cpp: Add printFunctionSignature helper

Testing:
- 5 comprehensive unit tests (all passing)
- Simple function split ‚úÖ
- Struct in header ‚úÖ
- Forward declarations ‚úÖ
- Pragma once mode ‚úÖ
- Header-only declarations ‚úÖ

Output Format:
.h file:
  - #ifndef / #define (or #pragma once)
  - Forward declarations
  - Struct definitions (complete)
  - Function declarations (signatures only)
  - #endif

.c file:
  - #include "header.h"
  - Function implementations (full bodies)

Breaking Changes: NONE
- TranspileResult.h was always there, now populated
- Existing code continues to work

User Requirement Met:
"We **must** emit .h files too. And include these into
the .c files for forward declarations." ‚úÖ

Quality:
- NO placeholders ‚úÖ
- NO TODO markers ‚úÖ
- Comprehensive tests ‚úÖ
- Full documentation ‚úÖ

Phase: 28-01
Type: Critical Fix - Header Generation
Status: COMPLETE ‚úÖ

ü§ñ Generated with [Claude Code](https://claude.com/claude-code)

Co-Authored-By: Claude Sonnet 4.5 <noreply@anthropic.com>
EOF
)"

git push origin develop
```

**Done When**: Changes committed and pushed

---

## Success Criteria

- [ ] HeaderSeparator integrated into pipeline
- [ ] CodeGenerator supports declarationOnly mode
- [ ] .h file has include guards
- [ ] .h file has forward declarations
- [ ] .h file has struct definitions
- [ ] .h file has function signatures
- [ ] .c file has #include "header.h"
- [ ] .c file has function implementations
- [ ] All 5 tests PASS
- [ ] Documentation updated
- [ ] NO placeholders
- [ ] NO TODO markers

---

## Verification Commands

```bash
# 1. Build library
cd /Users/alexanderfedin/Projects/hapyy/hupyy-cpp-to-c
cmake --build build_working --target cpptoc_static

# 2. Build tests
cmake --build build_working --target TranspilerAPI_HeaderSeparation_Test

# 3. Run tests
./build_working/tests/TranspilerAPI_HeaderSeparation_Test

# Expected: 5/5 tests PASS

# 4. Manual test
echo 'int add(int a, int b) { return a + b; }' > /tmp/test.cpp
./build_working/cpptoc /tmp/test.cpp

# Check output files have .h and .c with correct content

# 5. All tests
cd build_working
ctest --output-on-failure

# Expected: All tests PASS
```

---

**Status**: üìã Plan Ready for Execution
**Time Estimate**: 3-4 hours
**Priority**: CRITICAL (user requirement)
**Dependencies**: None (all infrastructure exists)
