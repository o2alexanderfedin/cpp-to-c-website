# Phase 16-04: WebAssembly Header Provisioning Mechanism

**Phase**: Runtime Integration Testing
**Plan**: 16-04 (WebAssembly Integration)
**Target**: Design and implement on-demand header loading for WebAssembly scenario
**Current**: WASM uses placeholder bindings, no header provisioning exists
**Priority**: CRITICAL - Enables real WASM transpiler functionality

---

## Objective

Design and implement mechanism for WebAssembly transpiler to handle headers when source code is provided as string without accompanying header files.

**Address user's critical concern**:
> "In our WebAssembly scenario, I saw that we provide transpiler with just a source. I don't know how that is gonna work with headers, that have to be loaded on-demand."

**Key Requirements**:
1. **Identify required headers** from C++ source code
2. **Provide header content on-demand** (cannot bundle Clang/LLVM in WASM)
3. **Support C standard library headers** (stdio.h, stdlib.h, etc.)
4. **Support C++ standard library** (iostream → stdio.h mapping)
5. **Enable custom header injection** via JavaScript API
6. **Test mechanism** with real transpilation scenarios

**Why this matters**:
- WASM cannot run Clang/LLVM (too large, filesystem dependencies)
- Headers must be provided externally via JavaScript/TypeScript
- Current WASM bindings are placeholders only
- This is the final piece for production-ready WASM transpiler

---

## Execution Context

<execution_context>
**Reference files**:
- `@wasm/bindings/minimal.cpp` - Current WASM placeholder
- `@wasm/bindings/full.cpp` - Full WASM placeholder
- `@wasm/CMakeLists.txt` - WASM build configuration
- `@wasm/glue/src/index.ts` - TypeScript wrapper API
- `@src/main.cpp` - CLI transpiler entry point
- `@tests/HeaderCompatibilityTest.cpp` - Header testing (from 16-02)
</execution_context>

---

## Context

**Investigation Findings**:

**Current WASM State**:
```cpp
// From wasm/bindings/minimal.cpp
std::string transpile(const std::string& source, const std::string& options) {
    // NOTE: Full Clang/LLVM integration pending
    // This is a PLACEHOLDER implementation
    return "/* Transpiled C code would go here */\n";
}
```

**Why Clang/LLVM Cannot Run in WASM**:
- Clang requires filesystem access (cannot use Emscripten's NO_FILESYSTEM)
- LLVM libraries are ~100MB+ (exceeds WASM size limits for edge deployment)
- Header search paths don't exist in WASM environment
- Compilation database requires file I/O

**Proposed Architecture**:
```
JavaScript/TypeScript Layer
    ↓ (provides)
Header Content Map: Map<string, string>
    ↓ (via)
WASM Module API
    ↓ (to)
Lightweight Parser (C++)
    ↓ (extracts)
Declarations from Headers
    ↓ (used by)
Simplified Transpiler (no Clang AST)
```

**Alternative Approaches**:

**Option A: Pre-transpile C++ with Headers on Server**
- Pros: Can use full Clang/LLVM
- Cons: Requires backend, not pure client-side

**Option B: JavaScript-Based Header Provisioning**
- Pros: Client-side only
- Cons: Need alternative to Clang AST parsing

**Option C: Hybrid - Preprocessed AST + WASM**
- Pros: Best of both worlds
- Cons: Complex architecture

---

## Tasks

<tasks>

### Task 1: Design Header Provisioning API
<task type="auto">
**Action**: Design JavaScript/TypeScript API for header provisioning

**TypeScript Interface Design**:
```typescript
// wasm/glue/src/types.ts

export interface HeaderProvider {
    /**
     * Get header content by name
     * @param headerName - e.g., "stdio.h", "vector", "custom/myheader.h"
     * @returns Header content as string, or null if not found
     */
    getHeader(headerName: string): string | null;

    /**
     * Check if header exists
     */
    hasHeader(headerName: string): boolean;

    /**
     * List all available headers
     */
    listHeaders(): string[];
}

export interface TranspileOptions {
    /**
     * Header provider for resolving #include directives
     */
    headerProvider?: HeaderProvider;

    /**
     * C++ standard version (11, 14, 17, 20)
     */
    cppStandard?: 11 | 14 | 17 | 20;

    /**
     * Enable ACSL annotation generation
     */
    enableACSL?: boolean;

    /**
     * ACSL annotation level (1-5)
     */
    acslLevel?: 1 | 2 | 3 | 4 | 5;
}

export interface TranspileResult {
    /**
     * Transpiled C code
     */
    code: string;

    /**
     * Header files generated (name → content)
     */
    headers: Map<string, string>;

    /**
     * Warnings and diagnostics
     */
    diagnostics: Diagnostic[];

    /**
     * Required headers not found
     */
    missingHeaders: string[];
}
```

**Built-in Header Providers**:
```typescript
// wasm/glue/src/headers/stdlib-provider.ts

export class CStandardLibraryProvider implements HeaderProvider {
    private headers = new Map<string, string>([
        ['stdio.h', STDIO_H_CONTENT],
        ['stdlib.h', STDLIB_H_CONTENT],
        ['string.h', STRING_H_CONTENT],
        ['math.h', MATH_H_CONTENT],
        ['assert.h', ASSERT_H_CONTENT],
        // ... more C stdlib headers
    ]);

    getHeader(name: string): string | null {
        return this.headers.get(name) || null;
    }

    hasHeader(name: string): boolean {
        return this.headers.has(name);
    }

    listHeaders(): string[] {
        return Array.from(this.headers.keys());
    }
}

export class CppStandardLibraryProvider implements HeaderProvider {
    // Maps C++ headers to C equivalents
    private mappings = new Map<string, string>([
        ['iostream', 'stdio.h'],
        ['vector', null], // Not supported (needs transpilation)
        ['string', null], // Maps to C char*
        // ...
    ]);

    getHeader(name: string): string | null {
        const mapped = this.mappings.get(name);
        if (mapped) {
            return cStdlibProvider.getHeader(mapped);
        }
        return null;
    }
}
```

**Usage Example**:
```typescript
import { transpile, CStandardLibraryProvider } from '@hupyy/cpptoc-wasm';

const cppCode = `
#include <stdio.h>
int main() {
    printf("Hello, World!\\n");
    return 0;
}
`;

const result = transpile(cppCode, {
    headerProvider: new CStandardLibraryProvider(),
    cppStandard: 17
});

console.log(result.code); // Transpiled C code
console.log(result.missingHeaders); // []
```

**Files**:
- Create `wasm/glue/src/types.ts`
- Create `wasm/glue/src/headers/stdlib-provider.ts`
- Create `wasm/glue/src/headers/cpp-stdlib-provider.ts`
- Update `wasm/glue/src/index.ts`

**Verify**:
```bash
cd /Users/alexanderfedin/Projects/hapyy/hupyy-cpp-to-c/wasm/glue
npm run build
npm test # TypeScript type checking
```

**Done when**:
- [ ] TypeScript types defined
- [ ] HeaderProvider interface documented
- [ ] Built-in providers implemented (C stdlib, C++ stdlib)
- [ ] Usage examples in documentation
- [ ] TypeScript compiles without errors
</task>

### Task 2: Implement Lightweight Header Parser (C++)
<task type="checkpoint:decision">
**Decision Point**: Choose transpiler architecture for WASM

**Options**:

**A. Simplified Parser (No Clang)**
- Pros: Small WASM bundle, no filesystem dependency
- Cons: Limited C++ support, complex to implement
- Estimate: ~2 weeks development

**B. Server-Side Preprocessing (Clang on backend)**
- Pros: Full Clang power, simple client
- Cons: Requires backend, not pure client-side
- Estimate: ~3 days development

**C. Pre-transpiled AST Approach**
- Pros: Serialize Clang AST on server, replay in WASM
- Cons: Very complex, AST serialization challenging
- Estimate: ~3 weeks development

**D. Hybrid: Critical Path in WASM, Full Path on Server**
- Pros: Fast simple cases client-side, complex cases server-side
- Cons: Two implementations to maintain
- Estimate: ~1 week development

**Recommendation**: Option B (Server-Side Preprocessing)
- Fastest to implement
- Leverages existing Clang/LLVM integration
- Can add client-side optimization later (Option D)
- Aligns with Phase 15 work (GTest, runtime testing)

**User Decision Required**:
Which architecture should we use for WASM transpiler?

</task>

### Task 3: Create WASM Header Integration Tests
<task type="auto">
**Action**: Test header provisioning mechanism with real scenarios

**Note**: Implementation depends on Task 2 architectural decision

**Test File**: `wasm/glue/tests/header-provisioning.test.ts`

**Tests**:
```typescript
import { describe, it, expect } from 'vitest';
import { transpile, CStandardLibraryProvider } from '../src/index';

describe('Header Provisioning', () => {
    it('should transpile simple stdio.h program', () => {
        const cpp = `
            #include <stdio.h>
            int main() {
                printf("test\\n");
                return 0;
            }
        `;

        const result = transpile(cpp, {
            headerProvider: new CStandardLibraryProvider()
        });

        expect(result.missingHeaders).toHaveLength(0);
        expect(result.code).toContain('printf');
        expect(result.diagnostics).toHaveLength(0);
    });

    it('should detect missing custom headers', () => {
        const cpp = `
            #include "custom/missing.h"
            int main() { return 0; }
        `;

        const result = transpile(cpp, {
            headerProvider: new CStandardLibraryProvider()
        });

        expect(result.missingHeaders).toContain('custom/missing.h');
    });

    it('should support custom header provider', () => {
        const customProvider = {
            getHeader(name: string) {
                if (name === 'myheader.h') {
                    return 'struct Point { int x; int y; };';
                }
                return null;
            },
            hasHeader(name: string) { return name === 'myheader.h'; },
            listHeaders() { return ['myheader.h']; }
        };

        const cpp = `
            #include "myheader.h"
            int main() {
                struct Point p = {1, 2};
                return 0;
            }
        `;

        const result = transpile(cpp, { headerProvider: customProvider });
        expect(result.missingHeaders).toHaveLength(0);
    });

    it('should handle multiple headers', () => {
        const cpp = `
            #include <stdio.h>
            #include <stdlib.h>
            #include <string.h>
            int main() {
                char* s = (char*)malloc(10);
                strcpy(s, "test");
                printf("%s\\n", s);
                free(s);
                return 0;
            }
        `;

        const result = transpile(cpp, {
            headerProvider: new CStandardLibraryProvider()
        });

        expect(result.missingHeaders).toHaveLength(0);
        expect(result.code).toContain('malloc');
        expect(result.code).toContain('strcpy');
    });

    it('should map C++ iostream to stdio.h', () => {
        const cpp = `
            #include <iostream>
            int main() {
                std::cout << "test" << std::endl;
                return 0;
            }
        `;

        const result = transpile(cpp, {
            headerProvider: new CppStandardLibraryProvider()
        });

        expect(result.code).toContain('printf');
        expect(result.code).not.toContain('std::cout');
    });
});
```

**Files**:
- Create `wasm/glue/tests/header-provisioning.test.ts`
- Update `wasm/glue/package.json` with test script

**Verify**:
```bash
cd /Users/alexanderfedin/Projects/hapyy/hupyy-cpp-to-c/wasm/glue
npm test
```

**Done when**:
- [ ] 5+ header provisioning tests implemented
- [ ] Tests cover: stdio, stdlib, string, custom headers
- [ ] C++ → C header mapping tested
- [ ] Missing header detection tested
- [ ] All tests pass
</task>

</tasks>

---

## Verification

Before declaring Phase 16-04 complete, verify ALL of these:

- ✓ TypeScript API designed and documented
- ✓ HeaderProvider interface implemented
- ✓ CStandardLibraryProvider working
- ✓ CppStandardLibraryProvider working (iostream → stdio.h)
- ✓ Custom header injection supported
- ✓ WASM transpiler architecture decided (Task 2 checkpoint)
- ✓ 5+ header provisioning tests passing
- ✓ Missing header detection working
- ✓ Multi-header scenarios tested
- ✓ Documentation includes usage examples

**If Option B (Server-Side) chosen**:
- ✓ Server API endpoint designed
- ✓ WASM module calls server for transpilation
- ✓ Header content passed to server

**If Option A/C/D chosen**:
- ✓ WASM module parses headers
- ✓ Header content used in transpilation
- ✓ Bundle size acceptable (<5MB)

---

## Success Criteria

- User's concern addressed: "headers loaded on-demand in WASM scenario"
- TypeScript API for header provisioning complete
- Built-in C stdlib headers available
- C++ stdlib header mapping working
- Custom header injection supported
- 5+ integration tests passing
- Architecture decision documented
- Clear path to production WASM transpiler

---

## Deviations Allowed

**Auto-fix bugs**: If header parsing fails, document limitations
**Auto-add missing critical**: If additional headers needed, add them
**Auto-fix blockers**: If WASM build fails, adjust flags
**Ask about architectural**: REQUIRED at Task 2 checkpoint (choose architecture)
**Log enhancements**: If some C++ features unsupported, log to ISSUES.md

All deviations documented in `16-04-SUMMARY.md`.

---

## Output

Create `16-04-SUMMARY.md` with:

```markdown
# Phase 16-04: WebAssembly Header Provisioning - SUMMARY

**Status**: [COMPLETE/PARTIAL/FAILED]
**Date**: [timestamp]
**Duration**: [hours]

## Deliverables

- [ ] TypeScript HeaderProvider API
- [ ] CStandardLibraryProvider
- [ ] CppStandardLibraryProvider
- [ ] Custom header injection support
- [ ] 5+ integration tests passing
- [ ] Architecture decision: [Option A/B/C/D]

## Architecture Decision

**Chosen**: Option [A/B/C/D]
**Rationale**: [Why this approach was selected]

## Header Support

- C stdlib headers: X/Y supported
- C++ stdlib mapping: X/Y mapped
- Custom headers: [SUPPORTED/NOT_SUPPORTED]

## Test Results

- Header provisioning tests: X/5 passing
- Missing header detection: [WORKING/BROKEN]
- Multi-header scenarios: [WORKING/BROKEN]

## WebAssembly Bundle

- Size: X MB (Brotli compressed)
- Load time: Xms
- Execution performance: [FAST/ACCEPTABLE/SLOW]

## Limitations

[Any C++ features not supported in WASM]

## Production Readiness

- [ ] API stable
- [ ] Tests comprehensive
- [ ] Documentation complete
- [ ] Performance acceptable

## Next Steps

- Deploy WASM module to CDN
- Integrate with web editor
- Add more header providers (e.g., Boost, SDL)
```

---

**Prepared by**: Claude Sonnet 4.5 (create-plans skill)
**Execution**: Run with `/run-plan .planning/phases/16-runtime-integration-testing/16-04-PLAN.md`
**Note**: Task 2 includes checkpoint:decision requiring user input
