# Phase 16-01: Runtime Testing Framework - Compile & Execute

**Phase**: Runtime Integration Testing
**Plan**: 16-01 (Foundation)
**Target**: Build systematic framework for compiling and executing transpiled C code
**Current**: Only 2 test files (ValidationTest.cpp) compile/execute C - 98% of tests are AST-only
**Priority**: CRITICAL - Runtime behavior is under-tested

---

## Objective

Create a robust runtime testing framework that systematically compiles transpiled C code with gcc/clang and executes it to verify correctness, establishing foundation for comprehensive end-to-end testing.

**Why this matters**:
- Current testing is 98% AST-level validation
- Output mismatch bugs exist (Phase 14 findings)
- No verification that transpiled code actually works
- Critical gap between "transpiler logic correct" and "generated C code works"

---

## Execution Context

<execution_context>
**Reference files** (load these first):
- `@tests/ValidationTest.cpp` - Existing runtime test patterns
- `@CMakeLists.txt` - Build system structure
- `@src/main.cpp` - Transpiler entry point
- `@test-reports/production-status-report-2025-12-21_16-41-05.md` - Current test status
</execution_context>

---

## Context

**Current State**:
- **ValidationTest.cpp** (323 lines) - Only file with gcc compilation + execution
- Uses `system()` calls to invoke gcc
- Ad-hoc output verification via string matching
- No systematic framework

**Testing Infrastructure**:
- Google Test (GTest) framework integrated (Phase 15)
- CTest discovery for test execution
- 50/101 test suites building and running
- 1,480 tests executing (95.3% pass rate)

**Build System**:
- CMake-based build
- LLVM/Clang 15+ required
- gcc/clang available for C compilation
- Supports `-std=c99` and `-std=c11`

**Key Insight from Investigation**:
- Transpiler generates correct AST transformations
- Unknown if generated C code compiles correctly
- Unknown if compiled C code executes correctly
- No systematic output comparison framework

---

## Tasks

<tasks>

### Task 1: Create RuntimeTestHarness Helper Class
<task type="auto">
**Action**: Create `tests/helpers/RuntimeTestHarness.h` and `.cpp`

**Implementation**:
```cpp
class RuntimeTestHarness {
public:
    struct CompilationResult {
        bool success;
        std::string stdout_output;
        std::string stderr_output;
        int exit_code;
    };

    struct ExecutionResult {
        bool success;
        std::string stdout_output;
        std::string stderr_output;
        int exit_code;
        double execution_time_ms;
    };

    // Transpile C++ code to C using the transpiler
    std::string transpile(const std::string& cpp_code,
                         const std::vector<std::string>& clang_args = {});

    // Compile C code with gcc/clang
    CompilationResult compileC(const std::string& c_code,
                               const std::string& compiler = "gcc",
                               const std::string& std_version = "c99",
                               const std::vector<std::string>& extra_flags = {});

    // Execute compiled binary
    ExecutionResult execute(const std::string& binary_path,
                           const std::vector<std::string>& args = {},
                           const std::string& stdin_data = "");

    // Full pipeline: transpile → compile → execute
    ExecutionResult transpileCompileExecute(
        const std::string& cpp_code,
        const std::vector<std::string>& clang_args = {},
        const std::vector<std::string>& runtime_args = {});

    // Cleanup temporary files
    ~RuntimeTestHarness() { cleanup(); }

private:
    std::string temp_dir_;
    std::vector<std::string> temp_files_;
    void cleanup();
    std::string createTempFile(const std::string& content, const std::string& extension);
};
```

**Features**:
- Automatic temporary file management
- Captures stdout, stderr, exit codes
- Execution time measurement
- Supports gcc and clang compilers
- Configurable C standard (c99, c11, c17)
- Integration with existing transpiler API

**Files**:
- Create `tests/helpers/RuntimeTestHarness.h`
- Create `tests/helpers/RuntimeTestHarness.cpp`
- Update `tests/helpers/CMakeLists.txt` to build the helper library

**Verify**:
```bash
# Build the helper library
cd /Users/alexanderfedin/Projects/hapyy/hupyy-cpp-to-c/build
cmake ..
make runtime_test_helpers -j8

# Check library exists
ls -lh tests/helpers/libruntime_test_helpers.a
```

**Done when**:
- [ ] RuntimeTestHarness.h created with complete API
- [ ] RuntimeTestHarness.cpp implements all methods
- [ ] Helper library compiles successfully
- [ ] Temporary file cleanup works correctly
</task>

### Task 2: Create RuntimeIntegrationTest Base Fixture
<task type="auto">
**Action**: Create GTest fixture for runtime tests in `tests/RuntimeIntegrationTest.cpp`

**Implementation**:
```cpp
class RuntimeIntegrationTest : public ::testing::Test {
protected:
    void SetUp() override {
        harness = std::make_unique<RuntimeTestHarness>();
    }

    void TearDown() override {
        harness.reset(); // Cleanup temp files
    }

    // Helper: Assert C code compiles
    void assertCompiles(const std::string& c_code) {
        auto result = harness->compileC(c_code);
        ASSERT_TRUE(result.success)
            << "Compilation failed:\n" << result.stderr_output;
    }

    // Helper: Assert transpiled C++ compiles and runs
    void assertTranspiledRuns(const std::string& cpp_code,
                             const std::string& expected_output = "") {
        auto result = harness->transpileCompileExecute(cpp_code);
        ASSERT_TRUE(result.success)
            << "Execution failed:\n" << result.stderr_output;

        if (!expected_output.empty()) {
            EXPECT_EQ(result.stdout_output, expected_output)
                << "Output mismatch";
        }
    }

    // Helper: Assert output matches regex
    void assertOutputMatches(const ExecutionResult& result,
                            const std::string& regex_pattern) {
        ASSERT_TRUE(result.success);
        EXPECT_TRUE(std::regex_search(result.stdout_output,
                                     std::regex(regex_pattern)));
    }

    std::unique_ptr<RuntimeTestHarness> harness;
};
```

**Initial Tests**:
```cpp
TEST_F(RuntimeIntegrationTest, SimpleFunctionTranspiles) {
    const char* code = R"(
        #include <stdio.h>
        int add(int a, int b) { return a + b; }
        int main() { printf("%d\n", add(2, 3)); return 0; }
    )";

    assertTranspiledRuns(code, "5\n");
}

TEST_F(RuntimeIntegrationTest, StructInitializationWorks) {
    const char* code = R"(
        #include <stdio.h>
        struct Point { int x; int y; };
        int main() {
            struct Point p = {10, 20};
            printf("%d %d\n", p.x, p.y);
            return 0;
        }
    )";

    assertTranspiledRuns(code, "10 20\n");
}
```

**Files**:
- Create `tests/RuntimeIntegrationTest.cpp`
- Add to `tests/CMakeLists.txt`

**Verify**:
```bash
cd /Users/alexanderfedin/Projects/hapyy/hupyy-cpp-to-c/build
cmake ..
make RuntimeIntegrationTest -j8
./RuntimeIntegrationTest --gtest_filter="*Simple*"
```

**Done when**:
- [ ] RuntimeIntegrationTest.cpp created
- [ ] Base fixture compiles
- [ ] Initial 2 tests pass
- [ ] Integrated with CTest
</task>

### Task 3: Add 10 Core Behavior Runtime Tests
<task type="auto">
**Action**: Expand `RuntimeIntegrationTest.cpp` with 10 fundamental behavior tests

**Test Coverage**:
1. **Arithmetic operations** - Verify basic math works
2. **Control flow** - if/else, loops, switch
3. **Function calls** - Parameters, return values
4. **Struct access** - Field reads/writes
5. **Pointer arithmetic** - Array indexing
6. **String operations** - Basic string manipulation
7. **Static variables** - Initialization and persistence
8. **Recursion** - Factorial, Fibonacci
9. **Multiple return paths** - Early returns
10. **Exit codes** - Non-zero exit codes

**Example Tests**:
```cpp
TEST_F(RuntimeIntegrationTest, ArithmeticOperations) {
    const char* code = R"(
        #include <stdio.h>
        int main() {
            int a = 10, b = 3;
            printf("%d %d %d %d\n", a+b, a-b, a*b, a/b);
            return 0;
        }
    )";
    assertTranspiledRuns(code, "13 7 30 3\n");
}

TEST_F(RuntimeIntegrationTest, RecursiveFactorial) {
    const char* code = R"(
        #include <stdio.h>
        int factorial(int n) {
            return n <= 1 ? 1 : n * factorial(n-1);
        }
        int main() {
            printf("%d\n", factorial(5));
            return 0;
        }
    )";
    assertTranspiledRuns(code, "120\n");
}

TEST_F(RuntimeIntegrationTest, NonZeroExitCode) {
    const char* code = R"(
        int main() { return 42; }
    )";
    auto result = harness->transpileCompileExecute(code);
    ASSERT_TRUE(result.success);
    EXPECT_EQ(result.exit_code, 42);
}
```

**Files**:
- Update `tests/RuntimeIntegrationTest.cpp` with 10 new tests

**Verify**:
```bash
cd /Users/alexanderfedin/Projects/hapyy/hupyy-cpp-to-c/build
make RuntimeIntegrationTest -j8
ctest -R RuntimeIntegrationTest -V
```

**Done when**:
- [ ] All 10 tests implemented
- [ ] All tests pass
- [ ] Code coverage includes fundamental C behaviors
- [ ] Execution time measured and reasonable (<100ms per test)
</task>

</tasks>

---

## Verification

Before declaring Phase 16-01 complete, verify ALL of these:

- ✓ RuntimeTestHarness library compiles successfully
- ✓ RuntimeTestHarness can transpile C++ to C
- ✓ RuntimeTestHarness can compile C code with gcc/clang
- ✓ RuntimeTestHarness can execute compiled binaries
- ✓ RuntimeIntegrationTest fixture compiles
- ✓ All 12 runtime tests pass (2 initial + 10 core)
- ✓ Temporary files cleaned up after tests
- ✓ CTest integration works
- ✓ Tests run in < 5 seconds total
- ✓ Zero memory leaks (run with valgrind if available)

---

## Success Criteria

- RuntimeTestHarness helper class fully implemented and tested
- GTest fixture for runtime tests established
- 12 runtime integration tests passing
- Framework ready for expansion (Phase 16-02, 16-03, 16-04)
- Documentation in code comments
- CMake integration complete

---

## Deviations Allowed

**Auto-fix bugs**: If transpiler generates invalid C (compiler errors), document and continue
**Auto-add missing critical**: If gcc requires specific flags, add them
**Auto-fix blockers**: If temp file creation fails, use different approach
**Ask about architectural**: N/A for this phase
**Log enhancements**: If valgrind not available, log to ISSUES.md

All deviations must be documented in `16-01-SUMMARY.md`.

---

## Output

Create `16-01-SUMMARY.md` with:

```markdown
# Phase 16-01: Runtime Testing Framework - SUMMARY

**Status**: [COMPLETE/PARTIAL/FAILED]
**Date**: [timestamp]
**Duration**: [hours]

## Deliverables

- [ ] RuntimeTestHarness library (tests/helpers/)
- [ ] RuntimeIntegrationTest fixture (tests/)
- [ ] 12 runtime integration tests passing
- [ ] CTest integration

## Test Results

- Tests implemented: X/12
- Tests passing: X/12
- Execution time: Xms
- Memory leaks: [none/found]

## Deviations

[List any deviations from plan, following embedded rules]

## Issues Found

[Any transpiler bugs discovered]

## Next Steps

- Phase 16-02: Header compatibility testing
- Phase 16-03: Console application tests
- Phase 16-04: WebAssembly header provisioning
```

---

**Prepared by**: Claude Sonnet 4.5 (create-plans skill)
**Execution**: Run with `/run-plan .planning/phases/16-runtime-integration-testing/16-01-PLAN.md`
