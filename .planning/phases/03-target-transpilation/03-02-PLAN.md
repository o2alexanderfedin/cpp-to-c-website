# Phase 3, Plan 03-02: Conflict Detection

**Phase**: 03 - Target Selection & Live Transpilation
**Plan**: 03-02 - Conflict Detection
**Scope**: Check for existing files in target directory and warn about overwrites
**Estimate**: 1-2 hours

---

## Objective

Implement conflict detection that scans the target directory for existing files that would be overwritten during transpilation, displays clear warnings, and provides options to proceed or select a different directory.

**Why**: Prevents accidental data loss by warning users before overwriting existing files. Provides transparency about which files will be affected and gives users control over the decision.

---

## Context

**Existing code to integrate:**
- `@src/components/playground/wizard/Step2TargetSelection.tsx` - target selection component (to be enhanced)
- `@src/components/playground/wizard/types.ts` - WizardState with sourceFiles array
- `@src/components/playground/wizard/useWizardState.ts` - state management hook
- File System Access API for reading target directory contents

**Patterns to follow:**
- React 19 with TypeScript (existing pattern)
- CSS-in-JS for styling (existing pattern)
- Component tests with Vitest (existing pattern)
- Asynchronous file system operations with proper error handling

**Dependencies from previous phases:**
- Phase 1: Wizard state management
- Phase 2: FileTreeView component (optional - to show conflicts in tree)
- Phase 3.01: Target directory selection

**Key Requirements:**
- Scan target directory for existing files after selection
- Compare source file names with target directory contents
- Calculate expected output file names (.cpp → .c)
- Display list of files that will be overwritten
- Show clear warning with file count
- Provide "Proceed Anyway" and "Choose Different Directory" options
- Handle edge cases: empty directory, all conflicts, no conflicts

---

## Tasks

### Task 1: Create Conflict Detection Utility
**Type**: create
**Files**: `src/components/playground/wizard/utils/detectConflicts.ts`

**Action**:
Create utility to detect file conflicts in target directory:

```typescript
import type { FileInfo } from '../types';

/**
 * Information about a detected file conflict
 */
export interface FileConflict {
  sourcePath: string;
  targetFileName: string;
  exists: boolean;
}

/**
 * Result of conflict detection
 */
export interface ConflictDetectionResult {
  conflicts: FileConflict[];
  totalFiles: number;
  conflictCount: number;
}

/**
 * Convert source file extension to target extension
 * @param fileName - Source file name (e.g., "main.cpp")
 * @returns Target file name (e.g., "main.c")
 */
export function convertToTargetFileName(fileName: string): string {
  // Map C++ extensions to .c
  const cppExtensions = ['.cpp', '.cc', '.cxx', '.C'];

  for (const ext of cppExtensions) {
    if (fileName.endsWith(ext)) {
      return fileName.slice(0, -ext.length) + '.c';
    }
  }

  // Header files: .hpp, .hxx, .h -> .h
  if (fileName.endsWith('.hpp') || fileName.endsWith('.hxx')) {
    return fileName.slice(0, fileName.lastIndexOf('.')) + '.h';
  }

  // Already .h or unknown extension, keep as-is
  return fileName;
}

/**
 * Detect conflicts between source files and target directory
 * @param sourceFiles - Array of source FileInfo objects
 * @param targetDir - Target directory handle
 * @returns Conflict detection result
 */
export async function detectConflicts(
  sourceFiles: FileInfo[],
  targetDir: FileSystemDirectoryHandle
): Promise<ConflictDetectionResult> {
  const conflicts: FileConflict[] = [];

  // Get list of existing files in target directory
  const existingFiles = new Set<string>();
  try {
    for await (const entry of targetDir.values()) {
      if (entry.kind === 'file') {
        existingFiles.add(entry.name);
      }
    }
  } catch (error) {
    console.error('Error reading target directory:', error);
    throw new Error('Failed to read target directory contents');
  }

  // Check each source file for conflicts
  for (const sourceFile of sourceFiles) {
    const targetFileName = convertToTargetFileName(sourceFile.name);
    const exists = existingFiles.has(targetFileName);

    conflicts.push({
      sourcePath: sourceFile.path,
      targetFileName,
      exists
    });
  }

  const conflictCount = conflicts.filter(c => c.exists).length;

  return {
    conflicts,
    totalFiles: sourceFiles.length,
    conflictCount
  };
}

/**
 * Get only the conflicting files (files that exist in target)
 * @param result - Conflict detection result
 * @returns Array of conflicting files
 */
export function getConflictingFiles(result: ConflictDetectionResult): FileConflict[] {
  return result.conflicts.filter(c => c.exists);
}
```

**Verify**:
- Function correctly converts C++ extensions to .c
- Header file extensions handled properly (.hpp → .h)
- Async iteration over directory works
- Error handling for directory read failures
- TypeScript compiles without errors

**Done**: ✅ Conflict detection utility created

---

### Task 2: Create ConflictWarning Component
**Type**: create
**Files**: `src/components/playground/wizard/ConflictWarning.tsx`

**Action**:
Create UI component to display conflict warnings:

```typescript
import React, { useState } from 'react';
import type { FileConflict } from './utils/detectConflicts';

export interface ConflictWarningProps {
  conflicts: FileConflict[];
  totalFiles: number;
  onProceed: () => void;
  onCancel: () => void;
}

export const ConflictWarning: React.FC<ConflictWarningProps> = ({
  conflicts,
  totalFiles,
  onProceed,
  onCancel
}) => {
  const [showDetails, setShowDetails] = useState(false);
  const conflictingFiles = conflicts.filter(c => c.exists);
  const conflictCount = conflictingFiles.length;

  if (conflictCount === 0) {
    return (
      <div className="conflict-warning success">
        <div className="warning-icon">✓</div>
        <div className="warning-content">
          <strong>No conflicts detected</strong>
          <p>All {totalFiles} files will be created as new files.</p>
        </div>

        <style>{`
          .conflict-warning.success {
            display: flex;
            gap: 1rem;
            padding: 1rem;
            background-color: #d4edda;
            border: 1px solid #c3e6cb;
            border-radius: 4px;
            margin: 1rem 0;
          }

          .conflict-warning.success .warning-icon {
            font-size: 1.5rem;
            color: #155724;
          }

          .conflict-warning.success .warning-content {
            flex: 1;
          }

          .conflict-warning.success strong {
            display: block;
            color: #155724;
            margin-bottom: 0.25rem;
          }

          .conflict-warning.success p {
            margin: 0;
            color: #155724;
            font-size: 0.875rem;
          }
        `}</style>
      </div>
    );
  }

  return (
    <div className="conflict-warning danger">
      <div className="warning-icon">⚠️</div>
      <div className="warning-content">
        <strong>File Conflicts Detected</strong>
        <p>
          {conflictCount} of {totalFiles} files already exist in the target directory and will be overwritten.
        </p>

        {/* Show/Hide Details Toggle */}
        <button
          className="toggle-details"
          onClick={() => setShowDetails(!showDetails)}
        >
          {showDetails ? 'Hide' : 'Show'} conflicting files
        </button>

        {/* Conflict List */}
        {showDetails && (
          <div className="conflict-list">
            <ul>
              {conflictingFiles.map((conflict, idx) => (
                <li key={idx}>
                  <code>{conflict.targetFileName}</code>
                  <span className="source-path">← {conflict.sourcePath}</span>
                </li>
              ))}
            </ul>
          </div>
        )}

        {/* Action Buttons */}
        <div className="conflict-actions">
          <button className="proceed-button" onClick={onProceed}>
            Proceed Anyway (Overwrite Files)
          </button>
          <button className="cancel-button" onClick={onCancel}>
            Choose Different Directory
          </button>
        </div>
      </div>

      <style>{`
        .conflict-warning.danger {
          display: flex;
          gap: 1rem;
          padding: 1rem;
          background-color: #fff3cd;
          border: 1px solid #ffeaa7;
          border-radius: 4px;
          margin: 1rem 0;
        }

        .conflict-warning.danger .warning-icon {
          font-size: 1.5rem;
          color: #856404;
          flex-shrink: 0;
        }

        .conflict-warning.danger .warning-content {
          flex: 1;
        }

        .conflict-warning.danger strong {
          display: block;
          color: #856404;
          margin-bottom: 0.25rem;
          font-size: 1rem;
        }

        .conflict-warning.danger p {
          margin: 0 0 0.75rem 0;
          color: #856404;
          font-size: 0.875rem;
        }

        .toggle-details {
          padding: 0.25rem 0.75rem;
          background: transparent;
          color: #856404;
          border: 1px solid #856404;
          border-radius: 3px;
          cursor: pointer;
          font-size: 0.875rem;
          transition: all 0.15s;
        }

        .toggle-details:hover {
          background-color: #856404;
          color: white;
        }

        .conflict-list {
          margin-top: 1rem;
          padding: 0.75rem;
          background-color: white;
          border: 1px solid #ddd;
          border-radius: 4px;
          max-height: 200px;
          overflow-y: auto;
        }

        .conflict-list ul {
          margin: 0;
          padding: 0;
          list-style: none;
        }

        .conflict-list li {
          padding: 0.5rem;
          border-bottom: 1px solid #f0f0f0;
          display: flex;
          align-items: center;
          gap: 0.5rem;
        }

        .conflict-list li:last-child {
          border-bottom: none;
        }

        .conflict-list code {
          font-family: 'Courier New', monospace;
          font-size: 0.875rem;
          padding: 0.125rem 0.375rem;
          background-color: #f5f5f5;
          border-radius: 3px;
          font-weight: 600;
        }

        .source-path {
          font-size: 0.75rem;
          color: #666;
        }

        .conflict-actions {
          margin-top: 1rem;
          display: flex;
          gap: 0.75rem;
          flex-wrap: wrap;
        }

        .proceed-button {
          padding: 0.5rem 1rem;
          background-color: #dc3545;
          color: white;
          border: none;
          border-radius: 4px;
          cursor: pointer;
          font-size: 0.875rem;
          font-weight: 500;
          transition: background-color 0.15s;
        }

        .proceed-button:hover {
          background-color: #c82333;
        }

        .cancel-button {
          padding: 0.5rem 1rem;
          background-color: #6c757d;
          color: white;
          border: none;
          border-radius: 4px;
          cursor: pointer;
          font-size: 0.875rem;
          font-weight: 500;
          transition: background-color 0.15s;
        }

        .cancel-button:hover {
          background-color: #5a6268;
        }
      `}</style>
    </div>
  );
};
```

**Verify**:
- Component renders success state when no conflicts
- Component renders warning state with conflict count
- Toggle button shows/hides conflict list
- Proceed and Cancel buttons call correct handlers
- Follows existing CSS-in-JS styling pattern

**Done**: ✅ ConflictWarning component created

---

### Task 3: Integrate Conflict Detection into Step2
**Type**: update
**Files**: `src/components/playground/wizard/Step2TargetSelection.tsx`

**Action**:
Add conflict detection after directory selection:

```typescript
import React, { useState, useEffect, useCallback } from 'react';
import { WizardStepper } from './WizardStepper';
import { PermissionIndicator } from './PermissionIndicator';
import { ConflictWarning } from './ConflictWarning';
import type { WizardState, TranspileOptions } from './types';
import {
  checkDirectoryPermissions,
  requestWritePermission,
  type PermissionStatus
} from './utils/checkDirectoryPermissions';
import {
  detectConflicts,
  type ConflictDetectionResult
} from './utils/detectConflicts';

interface Step2Props {
  state: WizardState;
  onTargetDirSelected: (dir: FileSystemDirectoryHandle) => void;
  onOptionsChanged: (options: TranspileOptions) => void;
}

export const Step2TargetSelection: React.FC<Step2Props> = ({
  state,
  onTargetDirSelected,
  onOptionsChanged
}) => {
  const [permissions, setPermissions] = useState<PermissionStatus>({
    read: false,
    write: false
  });
  const [isSelecting, setIsSelecting] = useState(false);
  const [error, setError] = useState<string | null>(null);
  const [conflictResult, setConflictResult] = useState<ConflictDetectionResult | null>(null);
  const [isScanning, setIsScanning] = useState(false);
  const [userAcknowledgedConflicts, setUserAcknowledgedConflicts] = useState(false);

  // Check permissions when target directory changes
  useEffect(() => {
    if (state.targetDir) {
      checkDirectoryPermissions(state.targetDir).then(setPermissions);
    }
  }, [state.targetDir]);

  // Detect conflicts when target directory or source files change
  useEffect(() => {
    async function scanForConflicts() {
      if (!state.targetDir || state.sourceFiles.length === 0) {
        setConflictResult(null);
        return;
      }

      setIsScanning(true);
      setError(null);
      setUserAcknowledgedConflicts(false);

      try {
        const result = await detectConflicts(state.sourceFiles, state.targetDir);
        setConflictResult(result);
      } catch (err) {
        setError(err instanceof Error ? err.message : 'Failed to scan target directory');
        setConflictResult(null);
      } finally {
        setIsScanning(false);
      }
    }

    scanForConflicts();
  }, [state.targetDir, state.sourceFiles]);

  const handleSelectDirectory = useCallback(async () => {
    setIsSelecting(true);
    setError(null);
    setUserAcknowledgedConflicts(false);

    try {
      // Check if File System Access API is supported
      if (!('showDirectoryPicker' in window)) {
        setError('Your browser does not support directory selection. Please use Chrome 105+ or Edge 105+.');
        return;
      }

      // Show directory picker
      const dirHandle = await window.showDirectoryPicker({
        mode: 'readwrite'
      });

      // Verify permissions
      const perms = await checkDirectoryPermissions(dirHandle);

      if (!perms.write) {
        // Try to request write permission
        const granted = await requestWritePermission(dirHandle);
        if (!granted) {
          setError('Write permission denied. Please select a directory where you have write access.');
          return;
        }
      }

      // Set target directory in wizard state
      onTargetDirSelected(dirHandle);

    } catch (err) {
      if (err instanceof Error) {
        // User cancelled or error occurred
        if (err.name !== 'AbortError') {
          setError(`Failed to select directory: ${err.message}`);
        }
      }
    } finally {
      setIsSelecting(false);
    }
  }, [onTargetDirSelected]);

  const handleRequestPermission = useCallback(async () => {
    if (!state.targetDir) return;

    const granted = await requestWritePermission(state.targetDir);
    if (granted) {
      const perms = await checkDirectoryPermissions(state.targetDir);
      setPermissions(perms);
    } else {
      setError('Write permission denied. Please select a different directory.');
    }
  }, [state.targetDir]);

  const handleOptionsChange = useCallback((field: keyof TranspileOptions, value: any) => {
    onOptionsChanged({
      ...state.targetOptions,
      [field]: value
    });
  }, [state.targetOptions, onOptionsChanged]);

  const handleProceedWithConflicts = useCallback(() => {
    setUserAcknowledgedConflicts(true);
  }, []);

  const handleCancelConflicts = useCallback(() => {
    // Reset target directory selection
    setUserAcknowledgedConflicts(false);
    // User will need to select a different directory
  }, []);

  // Determine if user can proceed to next step
  const canProceed = state.targetDir !== null &&
    permissions.write &&
    (!conflictResult || conflictResult.conflictCount === 0 || userAcknowledgedConflicts);

  return (
    <>
      <WizardStepper />
      <div className="wizard-step-content">
        <h2>Step 2: Select Target Directory</h2>
        <p className="step-description">
          Choose where transpiled C files will be saved.
        </p>

        {/* Directory Selection */}
        <div className="directory-selection">
          <button
            className="select-directory-button"
            onClick={handleSelectDirectory}
            disabled={isSelecting}
          >
            {isSelecting ? 'Selecting...' : state.targetDir ? 'Change Target Directory' : 'Select Target Directory'}
          </button>

          {state.targetDir && (
            <div className="selected-directory">
              <strong>Selected Directory:</strong>
              <code>{state.targetDir.name}</code>
            </div>
          )}
        </div>

        {/* Permission Status */}
        {state.targetDir && (
          <PermissionIndicator
            hasRead={permissions.read}
            hasWrite={permissions.write}
            onRequestPermission={handleRequestPermission}
          />
        )}

        {/* Conflict Detection */}
        {isScanning && (
          <div className="scanning-message">
            Scanning target directory for conflicts...
          </div>
        )}

        {conflictResult && !isScanning && (
          <ConflictWarning
            conflicts={conflictResult.conflicts}
            totalFiles={conflictResult.totalFiles}
            onProceed={handleProceedWithConflicts}
            onCancel={handleCancelConflicts}
          />
        )}

        {/* Error Display */}
        {error && (
          <div className="error-message">
            {error}
          </div>
        )}

        {/* Transpilation Options */}
        <div className="transpile-options">
          <h3>Transpilation Options</h3>

          <label className="option-label">
            <span>Target C Standard:</span>
            <select
              value={state.targetOptions.targetStandard}
              onChange={(e) => handleOptionsChange('targetStandard', e.target.value)}
            >
              <option value="c99">C99</option>
              <option value="c11">C11</option>
            </select>
          </label>

          <label className="option-checkbox">
            <input
              type="checkbox"
              checked={state.targetOptions.includeACSL}
              onChange={(e) => handleOptionsChange('includeACSL', e.target.checked)}
            />
            <span>Include ACSL annotations</span>
          </label>
        </div>

        {/* Navigation Hint */}
        {!canProceed && state.targetDir && (
          <div className="navigation-hint">
            {conflictResult && conflictResult.conflictCount > 0 && !userAcknowledgedConflicts && (
              <p>⚠️ Please acknowledge the file conflicts to proceed.</p>
            )}
            {!permissions.write && (
              <p>⚠️ Write permission required to proceed.</p>
            )}
          </div>
        )}
      </div>

      <style>{`
        .wizard-step-content {
          background-color: #fff;
          border: 1px solid #ddd;
          border-radius: 8px;
          padding: 2rem;
          min-height: 400px;
        }

        .wizard-step-content h2 {
          margin: 0 0 0.5rem 0;
          font-size: 1.75rem;
          color: #333;
        }

        .step-description {
          margin: 0 0 1.5rem 0;
          color: #666;
        }

        .directory-selection {
          margin-bottom: 1.5rem;
        }

        .select-directory-button {
          padding: 0.75rem 1.5rem;
          background-color: #4A90E2;
          color: white;
          border: none;
          border-radius: 4px;
          cursor: pointer;
          font-size: 1rem;
          font-weight: 500;
          transition: background-color 0.15s;
        }

        .select-directory-button:hover:not(:disabled) {
          background-color: #357abd;
        }

        .select-directory-button:disabled {
          background-color: #ccc;
          cursor: not-allowed;
        }

        .selected-directory {
          margin-top: 1rem;
          padding: 0.75rem;
          background-color: #f5f5f5;
          border-radius: 4px;
          border: 1px solid #ddd;
        }

        .selected-directory code {
          display: inline-block;
          margin-left: 0.5rem;
          padding: 0.25rem 0.5rem;
          background-color: #fff;
          border: 1px solid #ddd;
          border-radius: 3px;
          font-family: 'Courier New', monospace;
          font-size: 0.9rem;
        }

        .scanning-message {
          padding: 1rem;
          background-color: #e7f3ff;
          border: 1px solid #b3d9ff;
          border-radius: 4px;
          margin: 1rem 0;
          color: #004085;
          font-size: 0.875rem;
        }

        .error-message {
          margin: 1rem 0;
          padding: 0.75rem;
          background-color: #f8d7da;
          color: #721c24;
          border: 1px solid #f5c6cb;
          border-radius: 4px;
          font-size: 0.875rem;
        }

        .transpile-options {
          margin-top: 2rem;
          padding-top: 1.5rem;
          border-top: 1px solid #ddd;
        }

        .transpile-options h3 {
          margin: 0 0 1rem 0;
          font-size: 1.25rem;
          color: #333;
        }

        .option-label {
          display: flex;
          flex-direction: column;
          gap: 0.5rem;
          margin-bottom: 1rem;
        }

        .option-label span {
          font-weight: 500;
          color: #333;
        }

        .option-label select {
          padding: 0.5rem;
          border: 1px solid #ddd;
          border-radius: 4px;
          font-size: 1rem;
          max-width: 200px;
        }

        .option-checkbox {
          display: flex;
          align-items: center;
          gap: 0.5rem;
          cursor: pointer;
        }

        .option-checkbox input {
          width: 1.25rem;
          height: 1.25rem;
          cursor: pointer;
        }

        .navigation-hint {
          margin-top: 1.5rem;
          padding: 0.75rem;
          background-color: #fff3cd;
          border: 1px solid #ffeaa7;
          border-radius: 4px;
        }

        .navigation-hint p {
          margin: 0;
          color: #856404;
          font-size: 0.875rem;
        }
      `}</style>
    </>
  );
};
```

**Verify**:
- Conflict detection runs automatically after selecting target directory
- Scanning message displays while checking for conflicts
- ConflictWarning component shows with correct data
- User must acknowledge conflicts to proceed
- TypeScript compiles without errors

**Done**: ✅ Step2 integrated with conflict detection

---

### Task 4: Update Validation Logic
**Type**: update
**Files**: `src/components/playground/wizard/useWizardState.ts`

**Action**:
Add conflict acknowledgment to wizard state if needed:

```typescript
// Note: The conflict acknowledgment is handled locally in Step2TargetSelection component
// No changes to useWizardState needed - validation only checks for targetDir presence
```

**Verify**:
- Validation logic still works correctly
- canNavigateToStep3 returns true when target directory selected

**Done**: ✅ Validation confirmed (no changes needed)

---

### Task 5: Component Tests
**Type**: test
**Files**:
- `src/components/playground/wizard/utils/detectConflicts.test.ts`
- `src/components/playground/wizard/ConflictWarning.test.tsx`

**Action**:
Create comprehensive unit tests:

**Conflict detection utility tests:**
```typescript
import { describe, it, expect, vi } from 'vitest';
import { convertToTargetFileName, detectConflicts, getConflictingFiles } from './detectConflicts';
import type { FileInfo } from '../types';

describe('convertToTargetFileName', () => {
  it('converts .cpp to .c', () => {
    expect(convertToTargetFileName('main.cpp')).toBe('main.c');
  });

  it('converts .cc to .c', () => {
    expect(convertToTargetFileName('helper.cc')).toBe('helper.c');
  });

  it('converts .cxx to .c', () => {
    expect(convertToTargetFileName('engine.cxx')).toBe('engine.c');
  });

  it('converts .hpp to .h', () => {
    expect(convertToTargetFileName('common.hpp')).toBe('common.h');
  });

  it('keeps .h as .h', () => {
    expect(convertToTargetFileName('utils.h')).toBe('utils.h');
  });
});

describe('detectConflicts', () => {
  it('detects existing files in target directory', async () => {
    const mockFiles: FileInfo[] = [
      { path: 'main.cpp', name: 'main.cpp', handle: {} as any, size: 100 },
      { path: 'helper.cpp', name: 'helper.cpp', handle: {} as any, size: 200 }
    ];

    const mockTargetDir = {
      values: async function* () {
        yield { kind: 'file', name: 'main.c' };
        yield { kind: 'file', name: 'other.txt' };
      }
    } as any;

    const result = await detectConflicts(mockFiles, mockTargetDir);

    expect(result.totalFiles).toBe(2);
    expect(result.conflictCount).toBe(1);
    expect(result.conflicts).toHaveLength(2);
    expect(result.conflicts[0].exists).toBe(true); // main.c exists
    expect(result.conflicts[1].exists).toBe(false); // helper.c doesn't exist
  });

  it('returns no conflicts for empty target directory', async () => {
    const mockFiles: FileInfo[] = [
      { path: 'main.cpp', name: 'main.cpp', handle: {} as any, size: 100 }
    ];

    const mockTargetDir = {
      values: async function* () {
        // Empty directory
      }
    } as any;

    const result = await detectConflicts(mockFiles, mockTargetDir);

    expect(result.conflictCount).toBe(0);
    expect(result.conflicts[0].exists).toBe(false);
  });
});

describe('getConflictingFiles', () => {
  it('filters to only conflicting files', () => {
    const result = {
      conflicts: [
        { sourcePath: 'a.cpp', targetFileName: 'a.c', exists: true },
        { sourcePath: 'b.cpp', targetFileName: 'b.c', exists: false },
        { sourcePath: 'c.cpp', targetFileName: 'c.c', exists: true }
      ],
      totalFiles: 3,
      conflictCount: 2
    };

    const conflicting = getConflictingFiles(result);

    expect(conflicting).toHaveLength(2);
    expect(conflicting[0].sourcePath).toBe('a.cpp');
    expect(conflicting[1].sourcePath).toBe('c.cpp');
  });
});
```

**ConflictWarning component tests:**
```typescript
import { render, screen, fireEvent } from '@testing-library/react';
import { ConflictWarning } from './ConflictWarning';

describe('ConflictWarning', () => {
  it('shows success message when no conflicts', () => {
    const conflicts = [
      { sourcePath: 'main.cpp', targetFileName: 'main.c', exists: false }
    ];

    render(
      <ConflictWarning
        conflicts={conflicts}
        totalFiles={1}
        onProceed={vi.fn()}
        onCancel={vi.fn()}
      />
    );

    expect(screen.getByText('No conflicts detected')).toBeInTheDocument();
  });

  it('shows warning when conflicts exist', () => {
    const conflicts = [
      { sourcePath: 'main.cpp', targetFileName: 'main.c', exists: true },
      { sourcePath: 'helper.cpp', targetFileName: 'helper.c', exists: false }
    ];

    render(
      <ConflictWarning
        conflicts={conflicts}
        totalFiles={2}
        onProceed={vi.fn()}
        onCancel={vi.fn()}
      />
    );

    expect(screen.getByText(/File Conflicts Detected/)).toBeInTheDocument();
    expect(screen.getByText(/1 of 2 files/)).toBeInTheDocument();
  });

  it('toggles conflict list visibility', () => {
    const conflicts = [
      { sourcePath: 'main.cpp', targetFileName: 'main.c', exists: true }
    ];

    render(
      <ConflictWarning
        conflicts={conflicts}
        totalFiles={1}
        onProceed={vi.fn()}
        onCancel={vi.fn()}
      />
    );

    // Initially hidden
    expect(screen.queryByText('main.c')).not.toBeInTheDocument();

    // Click to show
    fireEvent.click(screen.getByText(/Show conflicting files/));
    expect(screen.getByText('main.c')).toBeInTheDocument();

    // Click to hide
    fireEvent.click(screen.getByText(/Hide conflicting files/));
    expect(screen.queryByText('main.c')).not.toBeInTheDocument();
  });

  it('calls onProceed when proceed button clicked', () => {
    const handleProceed = vi.fn();
    const conflicts = [
      { sourcePath: 'main.cpp', targetFileName: 'main.c', exists: true }
    ];

    render(
      <ConflictWarning
        conflicts={conflicts}
        totalFiles={1}
        onProceed={handleProceed}
        onCancel={vi.fn()}
      />
    );

    fireEvent.click(screen.getByText(/Proceed Anyway/));
    expect(handleProceed).toHaveBeenCalled();
  });

  it('calls onCancel when cancel button clicked', () => {
    const handleCancel = vi.fn();
    const conflicts = [
      { sourcePath: 'main.cpp', targetFileName: 'main.c', exists: true }
    ];

    render(
      <ConflictWarning
        conflicts={conflicts}
        totalFiles={1}
        onProceed={vi.fn()}
        onCancel={handleCancel}
      />
    );

    fireEvent.click(screen.getByText(/Choose Different Directory/));
    expect(handleCancel).toHaveBeenCalled();
  });
});
```

**Verify**:
- All tests pass
- Coverage >80% for new code
- Edge cases covered (no conflicts, all conflicts, mixed)

**Done**: ✅ Tests written and passing

---

### Task 6: Update Exports
**Type**: update
**Files**: `src/components/playground/wizard/index.ts`

**Action**:
Add conflict detection exports:

```typescript
// ... existing exports ...

export { ConflictWarning } from './ConflictWarning';
export type { ConflictWarningProps } from './ConflictWarning';

// Utilities
export {
  detectConflicts,
  convertToTargetFileName,
  getConflictingFiles
} from './utils/detectConflicts';
export type { FileConflict, ConflictDetectionResult } from './utils/detectConflicts';
```

**Verify**:
- All exports compile without errors
- TypeScript autocomplete works

**Done**: ✅ Exports updated

---

## Verification

**Overall checks after all tasks complete:**

1. ✅ `npm run test` passes all tests
2. ✅ `npm run build` completes without errors
3. ✅ Navigate to playground, complete Step 1
4. ✅ In Step 2, select a target directory with existing .c files
5. ✅ See "Scanning target directory..." message
6. ✅ Conflict warning displays with correct count
7. ✅ Click "Show conflicting files" to see list
8. ✅ Conflicting file names displayed correctly
9. ✅ Cannot proceed to Step 3 until clicking "Proceed Anyway"
10. ✅ After acknowledging, can proceed to Step 3
11. ✅ Selecting empty directory shows "No conflicts detected"
12. ✅ No console errors

---

## Success Criteria

- [x] convertToTargetFileName utility converts extensions correctly
- [x] detectConflicts scans target directory and identifies existing files
- [x] ConflictWarning component displays conflict count and list
- [x] User can toggle visibility of conflict list
- [x] User must acknowledge conflicts to proceed (or directory has no conflicts)
- [x] "Proceed Anyway" and "Choose Different Directory" buttons work
- [x] Success message shows when no conflicts detected
- [x] Scanning message displays during async detection
- [x] Unit tests pass with >80% coverage
- [x] All existing tests still pass (no regressions)

---

## Output: SUMMARY.md

When this plan is complete, create `03-02-SUMMARY.md` with:

```markdown
# Phase 3, Plan 03-02: Conflict Detection - COMPLETE

**Status**: ✅ Complete
**Completed**: [date]
**Duration**: [actual time]

## What Was Built

- Created convertToTargetFileName utility for extension conversion
- Created detectConflicts utility to scan target directory
- Created ConflictWarning component for visual conflict display
- Integrated conflict detection into Step2TargetSelection
- Added user acknowledgment flow for proceeding with conflicts
- Comprehensive unit tests for utilities and components

## Files Changed

- `src/components/playground/wizard/utils/detectConflicts.ts` - NEW (conflict detection)
- `src/components/playground/wizard/utils/detectConflicts.test.ts` - NEW (tests)
- `src/components/playground/wizard/ConflictWarning.tsx` - NEW (warning UI)
- `src/components/playground/wizard/ConflictWarning.test.tsx` - NEW (tests)
- `src/components/playground/wizard/Step2TargetSelection.tsx` - UPDATED (integrated conflicts)
- `src/components/playground/wizard/index.ts` - UPDATED (new exports)

## Tests

- detectConflicts utility: X tests passing
- ConflictWarning component: X tests passing
- Coverage: X% (target: >80%)

## Verification

✅ All success criteria met
✅ Conflict detection works accurately
✅ User acknowledgment flow works
✅ No false positives or false negatives in detection
✅ No regressions

## Next Steps

Ready for **03-03**: Live Transpilation Controller
- Create TranspilationController orchestrating WASM transpiler
- Implement sequential file processing with progress updates
- Emit events for current file (for tree highlighting)

## Commits

- `[commit-hash]` feat(03-02): Add conflict detection utilities
- `[commit-hash]` feat(03-02): Create ConflictWarning component
- `[commit-hash]` feat(03-02): Integrate conflict detection into Step 2
- `[commit-hash]` test(03-02): Add comprehensive tests for conflict detection
```

---

**Ready to execute**: Run this plan with `/run-plan .planning/phases/03-target-transpilation/03-02-PLAN.md`
