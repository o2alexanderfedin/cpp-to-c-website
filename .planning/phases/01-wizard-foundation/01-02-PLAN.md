# Phase 1, Plan 01-02: Wizard State & Step Shells

**Phase**: 01 - Wizard Foundation & Navigation
**Plan**: 01-02 - Wizard State & Step Shells
**Scope**: Central state management + empty step component shells
**Estimate**: 1-2 hours

---

## Objective

Create individual step component files and implement centralized wizard state management with step validation logic. This establishes the data flow architecture that all wizard steps will use.

**Why**: Separates concerns (each step in its own file), enables step-by-step validation (can't proceed without selecting directory), and provides a centralized state management pattern that all subsequent plans will build upon.

---

## Context

**Existing code from 01-01:**
- `@src/components/playground/wizard/PlaygroundWizard.tsx` - wizard shell with inline Step1-Step4 placeholder components
- `@src/components/playground/wizard/WizardStepper.tsx` - visual stepper component
- `@src/components/playground/wizard/index.ts` - barrel exports

**Existing playground components to reference:**
- `@src/components/playground/DirectorySelector.tsx` - directory selection pattern (will be integrated in later plans)
- `@src/components/playground/PlaygroundController.tsx` - current state management pattern
- `@src/components/playground/PlaygroundWrapper.tsx` - service instantiation pattern

**Patterns to follow:**
- React 19 with TypeScript (strict typing)
- React hooks for state management (useState, useCallback, useMemo)
- Component tests with Vitest and @testing-library/react
- CSS-in-JS for styling
- Export via index.ts barrel file

**No new dependencies needed** - using existing React hooks

---

## Tasks

### Task 1: Define Wizard State Interface
**Type**: create
**Files**: `src/components/playground/wizard/types.ts`

**Action**:
Create TypeScript interfaces for wizard state management:

```typescript
/**
 * Wizard state interface
 */
export interface WizardState {
  // Step 1: Source directory
  sourceDir: FileSystemDirectoryHandle | null;
  sourceFiles: FileInfo[];

  // Step 2: Target directory
  targetDir: FileSystemDirectoryHandle | null;
  targetOptions: TranspileOptions;

  // Step 3: Transpilation progress
  transpilationResults: Map<string, TranspileResult>;
  currentFile: string | null;
  isTranspiling: boolean;

  // Step 4: Results
  selectedPreviewFile: string | null;
}

/**
 * File information
 */
export interface FileInfo {
  path: string;
  name: string;
  handle: FileSystemFileHandle;
  size: number;
}

/**
 * Transpilation options
 */
export interface TranspileOptions {
  targetStandard: 'c99' | 'c11';
  includeACSL: boolean;
}

/**
 * Transpilation result
 */
export interface TranspileResult {
  success: boolean;
  cCode?: string;
  error?: string;
  diagnostics?: string[];
}
```

**Verify**:
- Types compile without errors
- Interfaces exported from types.ts

**Done**: ✅ Types defined and exported

---

### Task 2: Create Step Component Shells
**Type**: create
**Files**: `src/components/playground/wizard/Step1SourceSelection.tsx`, `Step2TargetSelection.tsx`, `Step3Transpilation.tsx`, `Step4Results.tsx`

**Action**:
Extract inline step components from PlaygroundWizard.tsx into separate files.

**Step1SourceSelection.tsx**:
```typescript
import React from 'react';
import { WizardStepper } from './WizardStepper';
import type { WizardState } from './types';

interface Step1Props {
  state: WizardState;
  onSourceDirSelected: (dir: FileSystemDirectoryHandle, files: FileInfo[]) => void;
}

export const Step1SourceSelection: React.FC<Step1Props> = ({ state, onSourceDirSelected }) => {
  return (
    <>
      <WizardStepper />
      <div className="wizard-step-content">
        <h2>Step 1: Select Source Directory</h2>
        <p>Select your C++ source directory (functionality coming in Phase 2)</p>
        {/* DirectorySelector will be integrated in Phase 2 */}
      </div>

      <style>{`
        .wizard-step-content {
          background-color: #fff;
          border: 1px solid #ddd;
          border-radius: 8px;
          padding: 2rem;
          min-height: 400px;
        }

        .wizard-step-content h2 {
          margin: 0 0 1rem 0;
          font-size: 1.75rem;
          color: #333;
        }
      `}</style>
    </>
  );
};
```

**Step2TargetSelection.tsx**:
```typescript
import React from 'react';
import { WizardStepper } from './WizardStepper';
import type { WizardState, TranspileOptions } from './types';

interface Step2Props {
  state: WizardState;
  onTargetDirSelected: (dir: FileSystemDirectoryHandle) => void;
  onOptionsChanged: (options: TranspileOptions) => void;
}

export const Step2TargetSelection: React.FC<Step2Props> = ({
  state,
  onTargetDirSelected,
  onOptionsChanged
}) => {
  return (
    <>
      <WizardStepper />
      <div className="wizard-step-content">
        <h2>Step 2: Select Target Directory</h2>
        <p>Configure transpilation options (functionality coming in Phase 3)</p>
      </div>

      <style>{`
        .wizard-step-content {
          background-color: #fff;
          border: 1px solid #ddd;
          border-radius: 8px;
          padding: 2rem;
          min-height: 400px;
        }
      `}</style>
    </>
  );
};
```

**Step3Transpilation.tsx**:
```typescript
import React from 'react';
import { WizardStepper } from './WizardStepper';
import type { WizardState } from './types';

interface Step3Props {
  state: WizardState;
  onStartTranspilation: () => void;
  onPauseTranspilation: () => void;
  onCancelTranspilation: () => void;
}

export const Step3Transpilation: React.FC<Step3Props> = ({
  state,
  onStartTranspilation,
  onPauseTranspilation,
  onCancelTranspilation
}) => {
  return (
    <>
      <WizardStepper />
      <div className="wizard-step-content">
        <h2>Step 3: Transpilation</h2>
        <p>Transpile with real-time progress (functionality coming in Phase 3)</p>
      </div>

      <style>{`
        .wizard-step-content {
          background-color: #fff;
          border: 1px solid #ddd;
          border-radius: 8px;
          padding: 2rem;
          min-height: 400px;
        }
      `}</style>
    </>
  );
};
```

**Step4Results.tsx**:
```typescript
import React from 'react';
import { WizardStepper } from './WizardStepper';
import type { WizardState } from './types';

interface Step4Props {
  state: WizardState;
  onFileSelected: (filePath: string) => void;
  onDownload: () => void;
}

export const Step4Results: React.FC<Step4Props> = ({
  state,
  onFileSelected,
  onDownload
}) => {
  return (
    <>
      <WizardStepper />
      <div className="wizard-step-content">
        <h2>Step 4: Results</h2>
        <p>View and download results (functionality coming in Phase 4)</p>
      </div>

      <style>{`
        .wizard-step-content {
          background-color: #fff;
          border: 1px solid #ddd;
          border-radius: 8px;
          padding: 2rem;
          min-height: 400px;
        }
      `}</style>
    </>
  );
};
```

**Verify**:
- All 4 step components created
- Each component accepts state and callback props
- TypeScript compiles without errors
- Components use consistent styling

**Done**: ✅ Step component shells created

---

### Task 3: Implement Wizard State Hook
**Type**: create
**Files**: `src/components/playground/wizard/useWizardState.ts`

**Action**:
Create a custom hook to manage wizard state:

```typescript
import { useState, useCallback } from 'react';
import type { WizardState, FileInfo, TranspileOptions, TranspileResult } from './types';

/**
 * Custom hook for wizard state management
 *
 * Provides centralized state and state update functions for all wizard steps
 */
export const useWizardState = () => {
  const [state, setState] = useState<WizardState>({
    sourceDir: null,
    sourceFiles: [],
    targetDir: null,
    targetOptions: {
      targetStandard: 'c99',
      includeACSL: true
    },
    transpilationResults: new Map(),
    currentFile: null,
    isTranspiling: false,
    selectedPreviewFile: null
  });

  // Step 1: Source directory handlers
  const setSourceDir = useCallback((dir: FileSystemDirectoryHandle, files: FileInfo[]) => {
    setState(prev => ({
      ...prev,
      sourceDir: dir,
      sourceFiles: files
    }));
  }, []);

  // Step 2: Target directory handlers
  const setTargetDir = useCallback((dir: FileSystemDirectoryHandle) => {
    setState(prev => ({
      ...prev,
      targetDir: dir
    }));
  }, []);

  const setTargetOptions = useCallback((options: TranspileOptions) => {
    setState(prev => ({
      ...prev,
      targetOptions: options
    }));
  }, []);

  // Step 3: Transpilation handlers
  const startTranspilation = useCallback(() => {
    setState(prev => ({
      ...prev,
      isTranspiling: true,
      transpilationResults: new Map(),
      currentFile: null
    }));
  }, []);

  const setCurrentFile = useCallback((filePath: string | null) => {
    setState(prev => ({
      ...prev,
      currentFile: filePath
    }));
  }, []);

  const addTranspilationResult = useCallback((filePath: string, result: TranspileResult) => {
    setState(prev => {
      const newResults = new Map(prev.transpilationResults);
      newResults.set(filePath, result);
      return {
        ...prev,
        transpilationResults: newResults
      };
    });
  }, []);

  const stopTranspilation = useCallback(() => {
    setState(prev => ({
      ...prev,
      isTranspiling: false,
      currentFile: null
    }));
  }, []);

  // Step 4: Results handlers
  const setSelectedPreviewFile = useCallback((filePath: string | null) => {
    setState(prev => ({
      ...prev,
      selectedPreviewFile: filePath
    }));
  }, []);

  // Validation functions
  const canNavigateToStep2 = useCallback(() => {
    return state.sourceDir !== null && state.sourceFiles.length > 0;
  }, [state.sourceDir, state.sourceFiles.length]);

  const canNavigateToStep3 = useCallback(() => {
    return state.targetDir !== null;
  }, [state.targetDir]);

  const canNavigateToStep4 = useCallback(() => {
    return state.transpilationResults.size > 0 && !state.isTranspiling;
  }, [state.transpilationResults.size, state.isTranspiling]);

  return {
    state,
    handlers: {
      setSourceDir,
      setTargetDir,
      setTargetOptions,
      startTranspilation,
      setCurrentFile,
      addTranspilationResult,
      stopTranspilation,
      setSelectedPreviewFile
    },
    validation: {
      canNavigateToStep2,
      canNavigateToStep3,
      canNavigateToStep4
    }
  };
};
```

**Verify**:
- Hook compiles without TypeScript errors
- All state update functions use useCallback for performance
- Validation functions return correct boolean values
- State updates are immutable (spread syntax)

**Done**: ✅ Wizard state hook created

---

### Task 4: Update PlaygroundWizard with State Management
**Type**: update
**Files**: `src/components/playground/wizard/PlaygroundWizard.tsx`

**Action**:
Update PlaygroundWizard to use the new state management hook and step components:

```typescript
import React from 'react';
import { Wizard } from 'react-use-wizard';
import { useWizardState } from './useWizardState';
import { Step1SourceSelection } from './Step1SourceSelection';
import { Step2TargetSelection } from './Step2TargetSelection';
import { Step3Transpilation } from './Step3Transpilation';
import { Step4Results } from './Step4Results';

export const PlaygroundWizard: React.FC = () => {
  const { state, handlers, validation } = useWizardState();

  return (
    <div className="playground-wizard">
      <Wizard>
        <Step1SourceSelection
          state={state}
          onSourceDirSelected={handlers.setSourceDir}
        />
        <Step2TargetSelection
          state={state}
          onTargetDirSelected={handlers.setTargetDir}
          onOptionsChanged={handlers.setTargetOptions}
        />
        <Step3Transpilation
          state={state}
          onStartTranspilation={handlers.startTranspilation}
          onPauseTranspilation={handlers.stopTranspilation}
          onCancelTranspilation={handlers.stopTranspilation}
        />
        <Step4Results
          state={state}
          onFileSelected={handlers.setSelectedPreviewFile}
          onDownload={() => {/* TODO: Implement in Phase 4 */}}
        />
      </Wizard>

      <style>{`
        .playground-wizard {
          max-width: 1200px;
          margin: 0 auto;
          padding: 2rem;
        }

        @media (max-width: 768px) {
          .playground-wizard {
            padding: 1rem;
          }
        }
      `}</style>
    </div>
  );
};
```

**Verify**:
- PlaygroundWizard uses useWizardState hook
- All step components receive state and handler props
- TypeScript compiles without errors
- Wizard still navigates through all 4 steps

**Done**: ✅ PlaygroundWizard updated with state management

---

### Task 5: Component Tests for State Management
**Type**: test
**Files**: `src/components/playground/wizard/useWizardState.test.ts`

**Action**:
Create unit tests for the state management hook:

```typescript
import { renderHook, act } from '@testing-library/react';
import { describe, it, expect } from 'vitest';
import { useWizardState } from './useWizardState';
import type { FileInfo, TranspileResult } from './types';

describe('useWizardState', () => {
  it('initializes with default state', () => {
    const { result } = renderHook(() => useWizardState());

    expect(result.current.state.sourceDir).toBeNull();
    expect(result.current.state.sourceFiles).toEqual([]);
    expect(result.current.state.targetDir).toBeNull();
    expect(result.current.state.targetOptions).toEqual({
      targetStandard: 'c99',
      includeACSL: true
    });
    expect(result.current.state.transpilationResults.size).toBe(0);
    expect(result.current.state.isTranspiling).toBe(false);
  });

  it('sets source directory and files', () => {
    const { result } = renderHook(() => useWizardState());
    const mockDir = {} as FileSystemDirectoryHandle;
    const mockFiles: FileInfo[] = [
      { path: 'test.cpp', name: 'test.cpp', handle: {} as FileSystemFileHandle, size: 100 }
    ];

    act(() => {
      result.current.handlers.setSourceDir(mockDir, mockFiles);
    });

    expect(result.current.state.sourceDir).toBe(mockDir);
    expect(result.current.state.sourceFiles).toEqual(mockFiles);
  });

  it('validates step 2 navigation requires source dir', () => {
    const { result } = renderHook(() => useWizardState());

    // Initially can't navigate (no source dir)
    expect(result.current.validation.canNavigateToStep2()).toBe(false);

    // After setting source dir, can navigate
    act(() => {
      result.current.handlers.setSourceDir(
        {} as FileSystemDirectoryHandle,
        [{ path: 'test.cpp', name: 'test.cpp', handle: {} as FileSystemFileHandle, size: 100 }]
      );
    });

    expect(result.current.validation.canNavigateToStep2()).toBe(true);
  });

  it('validates step 3 navigation requires target dir', () => {
    const { result } = renderHook(() => useWizardState());

    expect(result.current.validation.canNavigateToStep3()).toBe(false);

    act(() => {
      result.current.handlers.setTargetDir({} as FileSystemDirectoryHandle);
    });

    expect(result.current.validation.canNavigateToStep3()).toBe(true);
  });

  it('validates step 4 navigation requires completed transpilation', () => {
    const { result } = renderHook(() => useWizardState());

    expect(result.current.validation.canNavigateToStep4()).toBe(false);

    // Start transpilation
    act(() => {
      result.current.handlers.startTranspilation();
    });

    // Still can't navigate while transpiling
    expect(result.current.validation.canNavigateToStep4()).toBe(false);

    // Add result
    act(() => {
      const mockResult: TranspileResult = { success: true, cCode: '// code' };
      result.current.handlers.addTranspilationResult('test.cpp', mockResult);
    });

    // Still can't navigate while isTranspiling is true
    expect(result.current.validation.canNavigateToStep4()).toBe(false);

    // Stop transpilation
    act(() => {
      result.current.handlers.stopTranspilation();
    });

    // Now can navigate
    expect(result.current.validation.canNavigateToStep4()).toBe(true);
  });

  it('updates target options', () => {
    const { result } = renderHook(() => useWizardState());

    act(() => {
      result.current.handlers.setTargetOptions({
        targetStandard: 'c11',
        includeACSL: false
      });
    });

    expect(result.current.state.targetOptions).toEqual({
      targetStandard: 'c11',
      includeACSL: false
    });
  });

  it('tracks current file during transpilation', () => {
    const { result } = renderHook(() => useWizardState());

    act(() => {
      result.current.handlers.setCurrentFile('test.cpp');
    });

    expect(result.current.state.currentFile).toBe('test.cpp');

    act(() => {
      result.current.handlers.setCurrentFile(null);
    });

    expect(result.current.state.currentFile).toBeNull();
  });

  it('accumulates transpilation results', () => {
    const { result } = renderHook(() => useWizardState());

    const result1: TranspileResult = { success: true, cCode: '// file1' };
    const result2: TranspileResult = { success: false, error: 'Parse error' };

    act(() => {
      result.current.handlers.addTranspilationResult('file1.cpp', result1);
      result.current.handlers.addTranspilationResult('file2.cpp', result2);
    });

    expect(result.current.state.transpilationResults.size).toBe(2);
    expect(result.current.state.transpilationResults.get('file1.cpp')).toEqual(result1);
    expect(result.current.state.transpilationResults.get('file2.cpp')).toEqual(result2);
  });

  it('clears results when starting new transpilation', () => {
    const { result } = renderHook(() => useWizardState());

    // Add some results
    act(() => {
      result.current.handlers.addTranspilationResult('test.cpp', { success: true });
    });

    expect(result.current.state.transpilationResults.size).toBe(1);

    // Start new transpilation
    act(() => {
      result.current.handlers.startTranspilation();
    });

    expect(result.current.state.transpilationResults.size).toBe(0);
    expect(result.current.state.isTranspiling).toBe(true);
  });
});
```

**Verify**:
- All tests pass
- Coverage >80% for useWizardState
- Tests cover all state update functions
- Tests cover all validation functions

**Done**: ✅ State management tests created and passing

---

### Task 6: Update Exports
**Type**: update
**Files**: `src/components/playground/wizard/index.ts`

**Action**:
Update barrel export to include new components and types:

```typescript
// Components
export { WizardStepper } from './WizardStepper';
export { PlaygroundWizard } from './PlaygroundWizard';
export { Step1SourceSelection } from './Step1SourceSelection';
export { Step2TargetSelection } from './Step2TargetSelection';
export { Step3Transpilation } from './Step3Transpilation';
export { Step4Results } from './Step4Results';

// State management
export { useWizardState } from './useWizardState';

// Types
export type {
  WizardState,
  FileInfo,
  TranspileOptions,
  TranspileResult
} from './types';
```

**Verify**:
- All exports compile without errors
- Can import from '@/components/playground/wizard' in other files

**Done**: ✅ Exports updated

---

## Verification

**Overall checks after all tasks complete:**

1. ✅ `npm install` succeeds (no new dependencies, but verify existing work)
2. ✅ `npm run test` passes all tests (including new state management tests)
3. ✅ `npm run build` completes without errors
4. ✅ TypeScript compilation succeeds with no errors
5. ✅ Navigate to http://localhost:4321/cpp-to-c-website/playground
6. ✅ Can still navigate through all 4 wizard steps
7. ✅ Step components are now in separate files
8. ✅ No console errors in browser
9. ✅ State management hook tests pass (8+ tests)
10. ✅ All validation functions work correctly

---

## Success Criteria

- [x] WizardState interface defined with TypeScript
- [x] 4 step component shells created in separate files
- [x] useWizardState hook implements all state management
- [x] Validation functions enforce step-by-step progression
- [x] PlaygroundWizard uses state management hook
- [x] Unit tests pass with >80% coverage
- [x] All TypeScript compiles without errors
- [x] Wizard still navigates through all 4 steps
- [x] No regressions in existing tests

---

## Output: SUMMARY.md

When this plan is complete, create `01-02-SUMMARY.md` with:

```markdown
# Phase 1, Plan 01-02: Wizard State & Step Shells - COMPLETE

**Status**: ✅ Complete
**Completed**: [date]
**Duration**: [actual time]

## What Was Built

- Created WizardState TypeScript interface with validation
- Extracted 4 step components into separate files (Step1-Step4)
- Implemented useWizardState custom hook for centralized state management
- Added step validation logic (canNavigateToStep2/3/4)
- Updated PlaygroundWizard to use state management
- Added comprehensive unit tests for state hook (X tests, Y% coverage)

## Files Changed

- `src/components/playground/wizard/types.ts` - NEW (type definitions)
- `src/components/playground/wizard/useWizardState.ts` - NEW (state hook)
- `src/components/playground/wizard/useWizardState.test.ts` - NEW (tests)
- `src/components/playground/wizard/Step1SourceSelection.tsx` - NEW
- `src/components/playground/wizard/Step2TargetSelection.tsx` - NEW
- `src/components/playground/wizard/Step3Transpilation.tsx` - NEW
- `src/components/playground/wizard/Step4Results.tsx` - NEW
- `src/components/playground/wizard/PlaygroundWizard.tsx` - UPDATED (use state management)
- `src/components/playground/wizard/index.ts` - UPDATED (new exports)

## Tests

- State management tests: X passing, 0 failing
- Coverage: X% (target: >80%)
- All tests verify state updates, validation, and immutability

## Verification

✅ All success criteria met
✅ TypeScript compiles without errors
✅ Wizard navigates through all 4 steps
✅ State management hook works correctly
✅ Validation functions enforce step progression
✅ No regressions

## Deviations from Plan

[None] OR [List any changes made during implementation]

## Next Steps

Ready for **01-03**: Wizard E2E Tests
- Create end-to-end tests for wizard navigation
- Test step validation rules
- Test state persistence patterns

## Commits

- `[commit-hash]` feat(01-02): Add wizard state management and step shells
```

---

**Ready to execute**: Run this plan with `/run-plan .planning/phases/01-wizard-foundation/01-02-PLAN.md`
